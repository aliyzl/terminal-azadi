---
phase: 03-connection-engine
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/sysproxy/sysproxy.go
  - internal/sysproxy/detect.go
  - internal/sysproxy/sysproxy_test.go
  - internal/lifecycle/cleanup.go
autonomous: true
requirements:
  - CONN-05
  - CONN-06

must_haves:
  truths:
    - "App detects active macOS network service dynamically (Wi-Fi, Ethernet, etc.)"
    - "App sets SOCKS5 and HTTP/HTTPS system proxy via networksetup on connect"
    - "App unsets all three proxy types via networksetup on disconnect"
    - "On startup with dirty .state.json, app reverses system proxy and removes state file"
  artifacts:
    - path: "internal/sysproxy/detect.go"
      provides: "Active network service detection"
      exports: ["DetectNetworkService"]
    - path: "internal/sysproxy/sysproxy.go"
      provides: "System proxy set/unset via networksetup"
      exports: ["SetSystemProxy", "UnsetSystemProxy"]
    - path: "internal/sysproxy/sysproxy_test.go"
      provides: "Unit tests for sysproxy with command injection for testability"
      min_lines: 30
    - path: "internal/lifecycle/cleanup.go"
      provides: "Upgraded cleanup with actual networksetup proxy reversal"
      exports: ["RunCleanup"]
  key_links:
    - from: "internal/sysproxy/sysproxy.go"
      to: "os/exec"
      via: "exec.Command for networksetup calls"
      pattern: "exec\\.Command.*networksetup"
    - from: "internal/lifecycle/cleanup.go"
      to: "internal/sysproxy/sysproxy.go"
      via: "Calls UnsetSystemProxy with saved network service"
      pattern: "sysproxy\\.UnsetSystemProxy"
---

<objective>
Implement macOS system proxy management (detect active network service, set/unset proxy) and upgrade the --cleanup command to actually reverse dirty proxy state using networksetup.

Purpose: System proxy integration is what makes the VPN "just work" for all apps, not just those configured for SOCKS5. Cleanup is the safety net for crashes.
Output: internal/sysproxy/ package with Set/Unset/Detect, upgraded internal/lifecycle/cleanup.go.
</objective>

<execution_context>
@/Users/lee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-connection-engine/03-RESEARCH.md
@internal/lifecycle/cleanup.go
@internal/config/paths.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement system proxy detection and set/unset</name>
  <files>internal/sysproxy/detect.go, internal/sysproxy/sysproxy.go, internal/sysproxy/sysproxy_test.go</files>
  <action>
    Create internal/sysproxy/ package with two files:

    **detect.go** - DetectNetworkService() (string, error):
    - Run `networksetup -listallnetworkservices` via exec.Command
    - Parse output lines, skip header line ("An asterisk (*) denotes...") and disabled services (prefixed with *)
    - First pass: prefer "Wi-Fi" or any service containing "Ethernet" (case-sensitive match)
    - Second pass: return first non-disabled, non-empty service
    - Return error if no service found
    - Use a package-level `var execCommand = exec.Command` for testability (allows test to inject mock)

    **sysproxy.go** - SetSystemProxy(service string, socksPort, httpPort int) error:
    - Execute these networksetup commands in order (fail on first error):
      1. `-setsocksfirewallproxy <service> 127.0.0.1 <socksPort>`
      2. `-setsocksfirewallproxystate <service> on`
      3. `-setwebproxy <service> 127.0.0.1 <httpPort>`
      4. `-setwebproxystate <service> on`
      5. `-setsecurewebproxy <service> 127.0.0.1 <httpPort>`
      6. `-setsecurewebproxystate <service> on`
    - Wrap errors with fmt.Errorf including the failed command args
    - Use the same `execCommand` var for testability

    UnsetSystemProxy(service string) error:
    - Execute these networksetup commands in order:
      1. `-setsocksfirewallproxystate <service> off`
      2. `-setwebproxystate <service> off`
      3. `-setsecurewebproxystate <service> off`
    - Wrap errors with fmt.Errorf

    **sysproxy_test.go** - Tests using mock exec:
    - Override `execCommand` with a function that records calls and returns success
    - Test DetectNetworkService parses "Wi-Fi" from sample output
    - Test DetectNetworkService prefers Ethernet when Wi-Fi absent
    - Test DetectNetworkService skips disabled services (asterisk prefix)
    - Test DetectNetworkService returns error on empty list
    - Test SetSystemProxy calls 6 networksetup commands with correct args
    - Test UnsetSystemProxy calls 3 networksetup commands with correct args

    For mock exec pattern: Use TestHelperProcess approach (exec.Command redirected to test binary with -test.run=TestHelperProcess) OR simpler: make Set/Unset accept a CommandRunner interface/func for testing. Choose the simpler approach: package-level `var runCommand func(name string, args ...string) error` that defaults to running exec.Command but can be replaced in tests.
  </action>
  <verify>
    <automated>cd /Users/lee/vless-terminal && go test ./internal/sysproxy/ -v -count=1</automated>
    <manual>Verify detect.go and sysproxy.go exist with exported functions</manual>
  </verify>
  <done>DetectNetworkService finds active service from networksetup output. SetSystemProxy runs 6 commands. UnsetSystemProxy runs 3 commands. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Upgrade cleanup with actual proxy reversal</name>
  <files>internal/lifecycle/cleanup.go</files>
  <action>
    Upgrade RunCleanup in internal/lifecycle/cleanup.go to actually call networksetup to reverse dirty proxy state.

    Current code (Phase 1 stub) reads .state.json, reports dirty state, and removes the file -- but has a comment "Phase 3 will add actual networksetup commands here to unset proxy."

    Changes:
    1. Add import for the sysproxy package: `"github.com/leejooy96/azad/internal/sysproxy"`
    2. In the `if state.ProxySet` block, BEFORE the "Proxy state cleaned" message:
       - Call `sysproxy.UnsetSystemProxy(state.NetworkService)` to actually reverse the proxy
       - If UnsetSystemProxy fails, print a warning but continue (don't fail cleanup entirely -- user needs the state file removed even if networksetup fails)
       - Print "Reversed system proxy on: %s" with the network service name
    3. Remove the Phase 3 placeholder comment
    4. Keep the existing state file removal logic unchanged

    The cleanup flow becomes:
    1. Read .state.json
    2. If proxy was set: call sysproxy.UnsetSystemProxy to reverse it
    3. Print status messages
    4. Remove .state.json
    5. Done

    Do NOT modify RunResetTerminal -- that function is complete.
  </action>
  <verify>
    <automated>cd /Users/lee/vless-terminal && go build ./...</automated>
    <manual>Verify cleanup.go imports sysproxy and calls UnsetSystemProxy</manual>
  </verify>
  <done>RunCleanup calls sysproxy.UnsetSystemProxy with saved network service from .state.json. Cleanup both reverses proxy and removes state file. Build succeeds.</done>
</task>

</tasks>

<verification>
go build ./... succeeds (no import cycles, no missing symbols)
go test ./internal/sysproxy/ -v passes all tests
go vet ./internal/sysproxy/ ./internal/lifecycle/ passes
</verification>

<success_criteria>
- DetectNetworkService dynamically finds active macOS network service
- SetSystemProxy sets SOCKS5, HTTP, and HTTPS proxy via 6 networksetup commands
- UnsetSystemProxy disables all 3 proxy types via 3 networksetup commands
- RunCleanup actually reverses proxy state (not just reporting as in Phase 1)
- Tests verify command execution without requiring real networksetup
- Build compiles cleanly with no import cycles
</success_criteria>

<output>
After completion, create `.planning/phases/03-connection-engine/03-02-SUMMARY.md`
</output>
