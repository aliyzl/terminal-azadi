---
phase: 08-split-tunneling
plan: 03
type: execute
wave: 2
depends_on:
  - "08-01"
files_modified:
  - internal/tui/split_tunnel.go
  - internal/tui/app.go
  - internal/tui/keys.go
  - internal/tui/connect_cmd.go
  - internal/tui/messages.go
  - internal/tui/statusbar.go
autonomous: true
requirements:
  - SPLT-04

must_haves:
  truths:
    - "User can view split tunnel rules and mode from the TUI settings menu"
    - "User can add a split tunnel rule via input modal in the TUI"
    - "User can remove a split tunnel rule from the TUI"
    - "User can toggle split tunnel mode between exclusive and inclusive"
    - "User can enable/disable split tunneling from the TUI"
    - "Status bar shows SPLIT indicator when split tunneling is enabled"
    - "TUI connect commands pass split tunnel config to engine"
    - "Rule changes while connected show reconnect prompt"
  artifacts:
    - path: "internal/tui/split_tunnel.go"
      provides: "Split tunnel TUI view rendering and helper functions"
      exports: []
    - path: "internal/tui/app.go"
      provides: "viewSplitTunnel and viewAddSplitRule view states, split tunnel key handling"
      contains: "viewSplitTunnel"
    - path: "internal/tui/keys.go"
      provides: "SplitTunnel keybinding in settings menu"
      contains: "SplitTunnel"
    - path: "internal/tui/connect_cmd.go"
      provides: "Connect commands pass split tunnel config from cfg to engine"
      contains: "splitCfg"
    - path: "internal/tui/statusbar.go"
      provides: "SPLIT indicator in status bar"
      contains: "splitTunnel"
  key_links:
    - from: "internal/tui/app.go"
      to: "internal/tui/split_tunnel.go"
      via: "View() renders split tunnel overlay from view state"
      pattern: "viewSplitTunnel"
    - from: "internal/tui/connect_cmd.go"
      to: "internal/engine/engine.go"
      via: "Engine.Start called with split tunnel config"
      pattern: "eng\\.Start.*split"
    - from: "internal/tui/app.go"
      to: "internal/config/config.go"
      via: "Split tunnel rules read/written to cfg.SplitTunnel"
      pattern: "cfg\\.SplitTunnel"
---

<objective>
Add split tunnel management UI to the TUI with rule viewing, adding, removing, mode toggling, and status bar indicator. Wire TUI connect commands to pass split tunnel config to the engine.

Purpose: Users can manage split tunnel rules interactively through the TUI settings menu, see active split tunnel status, and have routing rules applied when connecting.
Output: Full TUI split tunnel management accessible from settings menu (m key), status bar indicator, connect commands pass split tunnel config.
</objective>

<execution_context>
@/Users/lee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-split-tunneling/08-RESEARCH.md
@.planning/phases/08-split-tunneling/08-01-SUMMARY.md

Key codebase files:
@internal/tui/app.go
@internal/tui/keys.go
@internal/tui/connect_cmd.go
@internal/tui/messages.go
@internal/tui/statusbar.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: TUI split tunnel view, input modal, and menu integration</name>
  <files>
    internal/tui/split_tunnel.go
    internal/tui/app.go
    internal/tui/keys.go
    internal/tui/messages.go
  </files>
  <action>
**internal/tui/messages.go:**
Add new message type:
```go
type splitTunnelSavedMsg struct{}
```

**internal/tui/keys.go:**
No new top-level keybinding needed. Split tunnel is accessed from the settings menu (m key), which already exists. The split tunnel view will use its own key routing.

**internal/tui/split_tunnel.go:**
Create new file with split tunnel view rendering and helper functions.

1. `splitTunnelSelectedIdx` field: Add to model struct in app.go as `splitTunnelIdx int` to track which rule is selected for deletion.

2. `renderSplitTunnelView(m model) string`: Renders the split tunnel management overlay.
   Layout:
   ```
   ╭───────── Split Tunneling ──────────╮
   │                                     │
   │  Status: [ENABLED / DISABLED]       │
   │  Mode: [exclusive / inclusive]       │
   │                                     │
   │  Rules:                             │
   │  > 1. 10.0.0.0/8       [cidr]      │
   │    2. *.google.com     [wildcard]   │
   │    3. example.com      [domain]     │
   │                                     │
   │  (No rules configured)              │
   │                                     │
   │  a · add rule   d · delete          │
   │  e · enable/disable  t · toggle mode│
   │  esc · back                         │
   ╰─────────────────────────────────────╯
   ```
   - Use lipgloss for styled rendering following existing overlay patterns (viewMenu, viewConfirmKillSwitch).
   - Highlight selected rule with ">" prefix and accent color.
   - Show status as green "ENABLED" or dim "DISABLED".
   - Show mode as "Exclusive (bypass list)" or "Inclusive (VPN-only list)".
   - Rules numbered with type annotation.

3. `buildSplitTunnelConfig(cfg *config.Config) *splittunnel.Config`: Helper to convert config.SplitTunnelConfig to runtime splittunnel.Config (same logic as in CLI connect.go). Import splittunnel package.

4. `saveSplitTunnelCmd(cfg *config.Config) tea.Cmd`: Returns a command that saves config to disk. Pattern: `config.FilePath()` then `config.Save(cfg, path)`. Returns `splitTunnelSavedMsg{}`.

**internal/tui/app.go:**
1. Add new view states to the viewState enum:
   - `viewSplitTunnel` (after viewConfirmKillSwitch)
   - `viewAddSplitRule` (input modal for adding a split tunnel rule)

2. Add field to model struct:
   - `splitTunnelIdx int` -- selected rule index in split tunnel view

3. In `handleKeyPress`, in the `viewMenu` case, add a new key handler for "t" (or "s" -- check for conflicts; use "t" for split tunnel):
   ```go
   case "t":
       m.view = viewSplitTunnel
       m.splitTunnelIdx = 0
       return m, nil
   ```
   Also update the viewMenu hint text to include the new option.

4. Add new `viewSplitTunnel` case in `handleKeyPress`:
   ```go
   case viewSplitTunnel:
       switch key {
       case "esc":
           m.view = viewMenu
           return m, nil
       case "j", "down":
           ruleCount := len(m.cfg.SplitTunnel.Rules)
           if ruleCount > 0 && m.splitTunnelIdx < ruleCount-1 {
               m.splitTunnelIdx++
           }
           return m, nil
       case "k", "up":
           if m.splitTunnelIdx > 0 {
               m.splitTunnelIdx--
           }
           return m, nil
       case "a":
           m.view = viewAddSplitRule
           cmd := m.input.SetMode(inputAddSplitRule) // Add new input mode
           return m, cmd
       case "d":
           ruleCount := len(m.cfg.SplitTunnel.Rules)
           if ruleCount > 0 && m.splitTunnelIdx < ruleCount {
               // Remove selected rule
               m.cfg.SplitTunnel.Rules = append(
                   m.cfg.SplitTunnel.Rules[:m.splitTunnelIdx],
                   m.cfg.SplitTunnel.Rules[m.splitTunnelIdx+1:]...,
               )
               if m.splitTunnelIdx >= len(m.cfg.SplitTunnel.Rules) && m.splitTunnelIdx > 0 {
                   m.splitTunnelIdx--
               }
               return m, saveSplitTunnelCmd(m.cfg)
           }
           return m, nil
       case "e":
           m.cfg.SplitTunnel.Enabled = !m.cfg.SplitTunnel.Enabled
           return m, saveSplitTunnelCmd(m.cfg)
       case "t":
           if m.cfg.SplitTunnel.Mode == "inclusive" {
               m.cfg.SplitTunnel.Mode = "exclusive"
           } else {
               m.cfg.SplitTunnel.Mode = "inclusive"
           }
           return m, saveSplitTunnelCmd(m.cfg)
       }
       return m, nil
   ```

5. Add `viewAddSplitRule` case in `handleKeyPress`:
   ```go
   case viewAddSplitRule:
       switch key {
       case "esc":
           m.view = viewSplitTunnel
           return m, nil
       case "enter":
           value := m.input.Value()
           if value == "" {
               return m, nil
           }
           rule, err := splittunnel.ParseRule(value)
           if err != nil {
               m.input.err = err
               return m, nil
           }
           m.cfg.SplitTunnel.Rules = append(m.cfg.SplitTunnel.Rules, config.SplitTunnelRule{
               Value: rule.Value,
               Type:  string(rule.Type),
           })
           m.view = viewSplitTunnel
           return m, saveSplitTunnelCmd(m.cfg)
       default:
           var cmd tea.Cmd
           m.input, cmd = m.input.Update(msg)
           return m, cmd
       }
   ```

6. Handle `tea.PasteMsg` for `viewAddSplitRule` -- add it alongside the existing viewAddServer/viewAddSubscription check.

7. Handle `splitTunnelSavedMsg` in Update: just return m, nil (config saved silently).

8. In `View()`, add render cases:
   - `viewSplitTunnel`: call `renderSplitTunnelView(m)` and overlay with `lipgloss.Place`.
   - `viewAddSplitRule`: render input modal (same pattern as viewAddServer).

9. In `viewMenu` render, add split tunnel row below kill switch row:
   ```
   ⇄  Split Tunnel      ● ENABLED / ○ OFF
   ```
   With hint updated to: "enter · toggle KS    t · split tunnel    esc · close"
   Also update the menu key handling: existing "enter" toggles kill switch. Add "t" to navigate to split tunnel view. The menu should show both options navigable. For simplicity, use "enter/space" for kill switch toggle (existing behavior) and "t" for split tunnel.

10. Add new input mode `inputAddSplitRule` to the input model. In the input.go file (or wherever input modes are defined), add the new constant and set placeholder text to "IP, CIDR, domain, or *.domain".

11. Default the mode: if `m.cfg.SplitTunnel.Mode == ""`, treat it as "exclusive" in all display and logic code.
  </action>
  <verify>
    <automated>cd /Users/lee/vless-terminal && go build ./... && go vet ./internal/tui/</automated>
    <manual>Run the TUI, press m for menu, press t to enter split tunnel view. Verify overlay renders correctly.</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>Split tunnel management accessible from settings menu via t key. Can view rules, add via input modal, remove with d, toggle enable/disable with e, switch mode with t. Rules persist to config file. View shows status, mode, and numbered rule list with type annotations.</done>
</task>

<task type="auto">
  <name>Task 2: TUI connect wiring and status bar split tunnel indicator</name>
  <files>
    internal/tui/connect_cmd.go
    internal/tui/statusbar.go
    internal/tui/app.go
  </files>
  <action>
**internal/tui/connect_cmd.go:**
1. Import `"github.com/leejooy96/azad/internal/splittunnel"`.

2. Modify `connectServerCmd` to accept split tunnel config:
   - Add `splitCfg *splittunnel.Config` parameter (after store parameter)
   - Pass to `eng.Start(context.Background(), srv, cfg.Proxy.SOCKSPort, cfg.Proxy.HTTPPort, splitCfg)`

3. Modify `autoConnectCmd` similarly:
   - Add `splitCfg *splittunnel.Config` parameter
   - Pass to `eng.Start(context.Background(), *server, cfg.Proxy.SOCKSPort, cfg.Proxy.HTTPPort, splitCfg)`

4. Update `enableKillSwitchCmd` to accept bypass IPs for split tunnel coordination:
   When the kill switch is enabled AND split tunnel is active in exclusive mode, extract bypass IPs from split tunnel rules. Add bypass IPs parameter:
   ```go
   func enableKillSwitchCmd(eng *engine.Engine, cfg *config.Config, bypassIPs ...[]string) tea.Cmd {
   ```
   Inside, pass bypassIPs to `killswitch.Enable(resolvedIP, srv.Port, bypass)`.

5. Add helper `buildSplitTunnelConfig` (if not already in split_tunnel.go):
   Converts `cfg.SplitTunnel` to `*splittunnel.Config`. Returns nil if disabled or no rules.

6. Add helper `extractBypassIPs(cfg *config.Config) []string`:
   If split tunnel is active in exclusive mode, extract IP/CIDR rules directly and resolve domain rules to IPs (best-effort, same pattern as CLI connect.go). Returns nil if inactive or inclusive mode.

**internal/tui/app.go:**
1. Update all calls to `connectServerCmd` to pass split tunnel config:
   ```go
   sc := buildSplitTunnelConfig(m.cfg)
   return m, connectServerCmd(item.server, m.engine, m.cfg, m.store, sc)
   ```
2. Update `autoConnectCmd` call in `Init()`:
   ```go
   sc := buildSplitTunnelConfig(m.cfg)
   return tea.Batch(tickCmd(), autoConnectCmd(m.store, m.engine, m.cfg, sc))
   ```
   But Init() doesn't have access to m. Actually Init() is a method on model. So:
   ```go
   func (m model) Init() tea.Cmd {
       sc := buildSplitTunnelConfig(m.cfg)
       return tea.Batch(tickCmd(), autoConnectCmd(m.store, m.engine, m.cfg, sc))
   }
   ```
3. Update reconnect sequence (disconnect+connect) to also pass split config.
4. Update kill switch enable calls to pass bypass IPs when split tunnel is active:
   ```go
   bypass := extractBypassIPs(m.cfg)
   return m, enableKillSwitchCmd(m.engine, m.cfg, bypass)
   ```

**internal/tui/statusbar.go:**
1. Add `splitTunnel bool` field to `statusBarModel`.
2. Add `SetSplitTunnel(active bool)` method.
3. In `View()`, after the kill switch indicator (if any), add split tunnel indicator:
   ```go
   if sb.splitTunnel {
       // Render "SPLIT" indicator in accent color
   }
   ```
   Follow the same pattern as the kill switch indicator.

**internal/tui/app.go (status bar updates):**
1. In model initialization (`New()`), check if split tunnel is enabled in config and set status bar accordingly:
   ```go
   if cfg.SplitTunnel.Enabled && len(cfg.SplitTunnel.Rules) > 0 {
       sb.SetSplitTunnel(true)
   }
   ```
2. When split tunnel is toggled (in viewSplitTunnel "e" key handler), update status bar:
   ```go
   m.statusBar.SetSplitTunnel(m.cfg.SplitTunnel.Enabled)
   ```
3. After `splitTunnelSavedMsg`, update status bar to reflect new state.
  </action>
  <verify>
    <automated>cd /Users/lee/vless-terminal && go build ./... && go vet ./internal/tui/</automated>
    <manual>Run TUI, add split tunnel rules via m > t > a, connect to a server, verify status bar shows SPLIT indicator. Verify connection works with split tunnel config passed to engine.</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>TUI connect commands pass split tunnel config to engine. Status bar shows SPLIT indicator when split tunneling is active. Kill switch enable includes bypass IPs for split tunnel coordination. Auto-connect and manual connect both respect split tunnel configuration.</done>
</task>

</tasks>

<verification>
1. `go build ./...` -- project compiles
2. `go vet ./internal/tui/` -- no vet issues
3. TUI menu (m key) shows split tunnel option
4. Split tunnel view (t from menu) renders correctly with rule list
5. Can add rules (a key), remove rules (d key), toggle enable (e key), switch mode (t key)
6. Status bar shows SPLIT indicator when enabled
7. Connecting passes split tunnel config to engine
8. Kill switch + split tunnel coordination works (bypass IPs passed)
</verification>

<success_criteria>
- Split tunnel management accessible from TUI settings menu
- Rule CRUD operations (add/remove/clear) work through modal input
- Mode toggle switches between exclusive and inclusive
- Enable/disable toggle persists to config
- Status bar shows SPLIT indicator when active
- Connect commands pass split tunnel config to Engine.Start
- Kill switch enable receives bypass IPs for pf coordination
- All existing TUI behavior unchanged when split tunnel is not configured
</success_criteria>

<output>
After completion, create `.planning/phases/08-split-tunneling/08-03-SUMMARY.md`
</output>
