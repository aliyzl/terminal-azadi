---
phase: 07-kill-switch
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/killswitch/rules.go
  - internal/killswitch/privilege.go
  - internal/killswitch/killswitch.go
  - internal/lifecycle/cleanup.go
autonomous: true
requirements: [KILL-01, KILL-02, KILL-04]

must_haves:
  truths:
    - "Kill switch pf rules block all non-VPN traffic when loaded into kernel"
    - "Firewall rules persist in kernel after process death (by design of pf)"
    - "Cleanup flushes only our anchor rules without touching Apple's pf state"
    - "ProxyState tracks kill switch active state for crash recovery"
  artifacts:
    - path: "internal/killswitch/rules.go"
      provides: "pf rule generation for kill switch"
      contains: "GenerateRules"
    - path: "internal/killswitch/privilege.go"
      provides: "osascript privilege escalation for pfctl commands"
      contains: "runPrivileged"
    - path: "internal/killswitch/killswitch.go"
      provides: "Enable/Disable/IsActive/Cleanup public API"
      exports: ["Enable", "Disable", "IsActive", "Cleanup"]
    - path: "internal/lifecycle/cleanup.go"
      provides: "Extended ProxyState with kill switch fields and cleanup integration"
      contains: "KillSwitchActive"
  key_links:
    - from: "internal/killswitch/killswitch.go"
      to: "internal/killswitch/rules.go"
      via: "GenerateRules called by Enable"
      pattern: "GenerateRules"
    - from: "internal/killswitch/killswitch.go"
      to: "internal/killswitch/privilege.go"
      via: "runPrivileged called for pfctl commands"
      pattern: "runPrivileged"
    - from: "internal/lifecycle/cleanup.go"
      to: "internal/killswitch/killswitch.go"
      via: "Cleanup calls killswitch.Cleanup to flush anchor"
      pattern: "killswitch\\.Cleanup"
---

<objective>
Create the killswitch package with pf rule generation, privilege escalation, and enable/disable API. Extend ProxyState for crash recovery and upgrade --cleanup to handle kill switch state.

Purpose: Provides the foundational kill switch infrastructure that Plan 02 wires into CLI and TUI flows.
Output: internal/killswitch/ package with Enable/Disable/IsActive/Cleanup; extended ProxyState; upgraded RunCleanup.
</objective>

<execution_context>
@/Users/lee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-kill-switch/07-RESEARCH.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/03-connection-engine/03-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create killswitch package with pf rules, privilege escalation, and public API</name>
  <files>internal/killswitch/rules.go, internal/killswitch/privilege.go, internal/killswitch/killswitch.go</files>
  <action>
Create `internal/killswitch/` package with three files:

**rules.go** - pf rule generation:
- `GenerateRules(serverIP string, serverPort int) string` generates pf anchor rules:
  - `set block-policy drop` (silent drops, no RST/ICMP)
  - `pass quick on lo0 all` (allow loopback for local SOCKS5/HTTP proxy)
  - `pass out quick proto {tcp, udp} from any to <serverIP> port <serverPort>` (allow VPN server traffic)
  - `pass quick proto {tcp, udp} from any port 67:68 to any port 67:68` (allow DHCP)
  - `pass out quick proto {tcp, udp} from any to any port 53` (allow DNS - safety net per research recommendation)
  - `block out all` and `block in all` (block everything else)
  - `block out inet6 all` and `block in inet6 all` (block IPv6 to prevent leak - per research pitfall 3)
- Rules are returned as a string, ready to pipe to pfctl.

**privilege.go** - privilege escalation:
- `runPrivileged(command string) error` runs a shell command via `osascript -e 'do shell script "..." with administrator privileges'`.
- Use `strings.ReplaceAll` to escape double quotes in the command string.
- `runPrivilegedOrSudo(command string) error` tries osascript first; if it fails (e.g. no GUI / SSH session), checks if current process is already root (`os.Getuid() == 0`) and runs the command directly via `exec.Command("sh", "-c", command)`. This handles the headless/sudo case from research open question 3.

**killswitch.go** - public API:
- `const anchorName = "com.azad.killswitch"` - the pf anchor name.
- `Enable(serverIP string, serverPort int) error`:
  1. Call `GenerateRules(serverIP, serverPort)` to get rule string.
  2. Base64-encode rules to safely pass through shell escaping.
  3. Run via `runPrivilegedOrSudo`: `echo <base64> | base64 -d | /sbin/pfctl -a com.azad.killswitch -f - && /sbin/pfctl -E`
  4. Return error on failure.
- `Disable() error`:
  1. Run via `runPrivilegedOrSudo`: `/sbin/pfctl -a com.azad.killswitch -F all`
  2. Do NOT call `pfctl -d` (would disable ALL pf including Apple's rules - per research anti-pattern).
  3. Return error on failure.
- `IsActive() bool`:
  1. Run `pfctl -a com.azad.killswitch -sr 2>/dev/null` (does not need sudo for read).
  2. If output is non-empty (has rules), return true.
  3. If empty or error, return false.
- `Cleanup() error`:
  Same as Disable() but with softer error handling -- if privilege escalation fails, print manual recovery command: "If locked out, run: sudo pfctl -a com.azad.killswitch -F all"

Use `os/exec` and `encoding/base64` from stdlib. Follow the existing `runCommand` pattern from `internal/sysproxy/` for testability -- use a package-level `var execCommand = exec.Command` that tests can replace.
  </action>
  <verify>
    <automated>cd /Users/lee/vless-terminal && go build ./internal/killswitch/ && go vet ./internal/killswitch/</automated>
    <manual>Review that rules include IPv6 blocking, loopback pass, DHCP pass, DNS pass, and server-specific pass</manual>
  </verify>
  <done>killswitch package compiles with Enable/Disable/IsActive/Cleanup functions; GenerateRules produces correct pf syntax with IPv4+IPv6 blocking; privilege escalation handles both GUI (osascript) and headless (sudo) modes</done>
</task>

<task type="auto">
  <name>Task 2: Extend ProxyState for kill switch and upgrade RunCleanup</name>
  <files>internal/lifecycle/cleanup.go</files>
  <action>
Extend the existing `lifecycle.ProxyState` struct with kill switch fields and upgrade `RunCleanup` to handle kill switch state.

**ProxyState extension** (in cleanup.go):
Add three new fields to the existing ProxyState struct:
```go
KillSwitchActive bool   `json:"kill_switch_active,omitempty"`
ServerAddress    string `json:"server_address,omitempty"`    // Remote server IP for rule regeneration
ServerPort       int    `json:"server_port,omitempty"`       // Remote server port
```
Use `omitempty` JSON tags so existing state files without these fields remain compatible (backwards-compatible -- per research pitfall 6).

**RunCleanup upgrade** (in cleanup.go):
After the existing system proxy cleanup logic, add kill switch cleanup:
1. Check `state.KillSwitchActive` -- if true:
   a. Print "Found active kill switch from previous session."
   b. Call `killswitch.Cleanup()` to flush the pf anchor rules.
   c. If cleanup succeeds, print "Kill switch firewall rules removed."
   d. If cleanup fails, print warning with manual recovery command: "Manual recovery: sudo pfctl -a com.azad.killswitch -F all"
2. The existing state file removal at the end handles both proxy and kill switch state cleanup.

Import `github.com/leejooy96/azad/internal/killswitch` in cleanup.go.

Do NOT modify the RunResetTerminal function -- it is unrelated.
  </action>
  <verify>
    <automated>cd /Users/lee/vless-terminal && go build ./internal/lifecycle/ && go vet ./internal/lifecycle/</automated>
    <manual>Verify ProxyState has kill_switch_active, server_address, server_port fields; RunCleanup calls killswitch.Cleanup when kill switch was active</manual>
  </verify>
  <done>ProxyState has KillSwitchActive/ServerAddress/ServerPort fields with omitempty; RunCleanup detects active kill switch state and flushes pf anchor rules; backwards-compatible with existing state files that lack kill switch fields</done>
</task>

</tasks>

<verification>
1. `go build ./...` passes (entire project compiles with new killswitch package)
2. `go vet ./internal/killswitch/ ./internal/lifecycle/` passes
3. killswitch.GenerateRules("1.2.3.4", 443) returns valid pf rule string with IPv6 blocking
4. killswitch.IsActive() returns false when no rules are loaded
5. ProxyState JSON marshaling includes kill_switch_active when true, omits when false
</verification>

<success_criteria>
- internal/killswitch/ package exists with rules.go, privilege.go, killswitch.go
- Enable/Disable/IsActive/Cleanup functions compile and have correct signatures
- pf rules include: block-policy drop, loopback pass, server pass, DHCP pass, DNS pass, IPv6 block, catch-all block
- ProxyState extended with kill switch fields (backwards-compatible)
- RunCleanup handles both proxy state AND kill switch state cleanup
- No import cycles; clean compilation
</success_criteria>

<output>
After completion, create `.planning/phases/07-kill-switch/07-01-SUMMARY.md`
</output>
