---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - internal/config/config.go
  - internal/config/paths.go
  - internal/lifecycle/signals.go
  - internal/lifecycle/cleanup.go
  - internal/cli/root.go
  - internal/cli/config_cmd.go
  - cmd/azad/main.go
autonomous: true
requirements:
  - FNDN-02
  - FNDN-04

must_haves:
  truths:
    - "App reads config from ~/.config/azad/config.yaml with correct defaults (socks_port=1080, http_port=8080)"
    - "App writes config to disk and values persist across runs"
    - "App creates config directory and file on first run if they do not exist"
    - "Sending SIGINT to the running process triggers graceful shutdown"
    - "Running azad --cleanup reads proxy state file and reports cleanup action (or no-op if clean)"
    - "Running azad --reset-terminal attempts terminal state restoration"
  artifacts:
    - path: "internal/config/config.go"
      provides: "Config struct with koanf load/save, defaults"
      exports: ["Config", "Load", "Save"]
      min_lines: 40
    - path: "internal/config/paths.go"
      provides: "XDG path resolution for config directory and file"
      exports: ["Dir", "FilePath", "EnsureDir"]
      min_lines: 20
    - path: "internal/lifecycle/signals.go"
      provides: "Signal handling with context cancellation"
      exports: ["WithShutdown"]
      min_lines: 10
    - path: "internal/lifecycle/cleanup.go"
      provides: "Cleanup and terminal reset logic"
      exports: ["RunCleanup", "RunResetTerminal"]
      min_lines: 30
  key_links:
    - from: "internal/cli/root.go"
      to: "internal/lifecycle/cleanup.go"
      via: "PersistentPreRunE calls lifecycle.RunCleanup"
      pattern: "lifecycle\\.RunCleanup"
    - from: "internal/cli/root.go"
      to: "internal/config/config.go"
      via: "config.Load() called during command setup"
      pattern: "config\\.Load"
    - from: "internal/config/config.go"
      to: "internal/config/paths.go"
      via: "Load/Save use paths.FilePath for config location"
      pattern: "FilePath"
    - from: "cmd/azad/main.go"
      to: "internal/lifecycle/signals.go"
      via: "lifecycle.WithShutdown wraps main context"
      pattern: "lifecycle\\.WithShutdown"
---

<objective>
Implement the koanf-based YAML configuration system with XDG-compliant paths and add graceful signal handling with crash-recovery commands (--cleanup, --reset-terminal).

Purpose: Complete the foundation layer so the binary persists user preferences and handles crashes safely. This is the safety net that every subsequent phase depends on -- without config persistence, servers can't be remembered; without signal handling, crashes corrupt system proxy state.
Output: Config reads/writes to `~/.config/azad/config.yaml`. Signal handling via context cancellation. `--cleanup` and `--reset-terminal` are functional commands.
</objective>

<execution_context>
@/Users/lee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement koanf config system with XDG paths</name>
  <files>
    internal/config/paths.go
    internal/config/config.go
    internal/cli/config_cmd.go
  </files>
  <action>
1. Create `internal/config/paths.go`:
   - Package `config`
   - `const appName = "azad"` and `const configFileName = "config.yaml"`
   - `func Dir() (string, error)` — uses `os.UserConfigDir()` + filepath.Join with appName
   - `func FilePath() (string, error)` — Dir() + configFileName
   - `func EnsureDir() error` — Dir() + `os.MkdirAll(dir, 0700)`
   - `func DataDir() (string, error)` — uses Dir() for now (data lives alongside config in Phase 1; can split to XDG_DATA_HOME later)
   - `func StateFilePath() (string, error)` — Dir() + ".state.json" (for proxy state tracking used by --cleanup)

2. Create `internal/config/config.go`:
   - Package `config`
   - Define structs:
     ```
     Config struct with koanf tags:
       Proxy ProxyConfig `koanf:"proxy"`
       Server ServerConfig `koanf:"server"`
     ProxyConfig:
       SOCKSPort int `koanf:"socks_port"` (default 1080)
       HTTPPort int `koanf:"http_port"` (default 8080)
     ServerConfig:
       LastUsed string `koanf:"last_used"`
     ```
   - `func Defaults() *Config` — returns Config with SOCKSPort=1080, HTTPPort=8080
   - `func Load(path string) (*Config, error)`:
     a. Create new koanf instance with "." delimiter
     b. Load defaults via confmap.Provider with dot-notation keys
     c. Check `os.Stat(path)` — if file exists, load via file.Provider + yaml.Parser()
     d. Unmarshal into Config struct
     e. Return config
   - `func Save(cfg *Config, path string) error`:
     a. `EnsureDir()` to create directory
     b. Create new koanf instance (fresh, not global — avoid race conditions per RESEARCH anti-patterns)
     c. Load struct into koanf via structs.Provider(cfg, "koanf")
     d. Marshal via yaml.Parser()
     e. `os.WriteFile(path, b, 0600)`
   - Do NOT use package-level koanf instance for writes (anti-pattern from RESEARCH.md)

3. Update `internal/cli/config_cmd.go`:
   - Wire `newConfigCmd()` to load config and print current values as YAML to stdout
   - Add `config set <key> <value>` subcommand (optional for Phase 1 — if straightforward, include; if complex, defer)
   - At minimum: `azad config` shows current config path and values

4. Run `go build ./cmd/azad` and `go vet ./...` to verify.

IMPORT PATHS: Use `github.com/knadh/koanf/v2` (not v1), `github.com/knadh/koanf/parsers/yaml`, `github.com/knadh/koanf/providers/file`, `github.com/knadh/koanf/providers/confmap`, `github.com/knadh/koanf/providers/structs`. These are separate Go modules with their own import paths under the koanf umbrella.

GOTCHA: koanf `structs` provider requires the struct tag name as second arg. Use "koanf" to match the struct tags. Import path is `github.com/knadh/koanf/providers/structs`.
  </action>
  <verify>
    <automated>cd /Users/lee/vless-terminal && go build -o azad ./cmd/azad && ./azad config 2>&1 | head -20 && echo "PASS: config command works"</automated>
    <manual>Run ./azad config and verify it shows config path and default values (socks_port: 1080, http_port: 8080)</manual>
  </verify>
  <done>Config loads from ~/.config/azad/config.yaml with defaults. Config saves to disk. `azad config` displays current configuration. Config directory created with 0700 permissions. Config file written with 0600 permissions.</done>
</task>

<task type="auto">
  <name>Task 2: Implement signal handling and cleanup commands</name>
  <files>
    internal/lifecycle/signals.go
    internal/lifecycle/cleanup.go
    internal/cli/root.go
    cmd/azad/main.go
  </files>
  <action>
1. Create `internal/lifecycle/signals.go`:
   - Package `lifecycle`
   - `func WithShutdown(parent context.Context) (context.Context, context.CancelFunc)` — wraps `signal.NotifyContext(parent, os.Interrupt, syscall.SIGTERM)`
   - Clean, minimal implementation per RESEARCH Pattern 3

2. Create `internal/lifecycle/cleanup.go`:
   - Package `lifecycle`
   - `func RunCleanup(configDir string) error`:
     a. Construct state file path: `filepath.Join(configDir, ".state.json")`
     b. Check if state file exists via `os.Stat`
     c. If exists: read JSON, parse `proxy_set` bool, `socks_port`, `http_port`, `network_service` fields
     d. If proxy_set is true: print what would be cleaned (in Phase 1 this is informational only — actual networksetup commands come in Phase 3). Print "Proxy state cleaned" and remove state file.
     e. If no state file: print "No dirty proxy state found. System is clean."
   - `func RunResetTerminal() error`:
     a. Try `term.GetState(int(os.Stdin.Fd()))` — if terminal is already in normal mode, print "Terminal is already in normal state"
     b. As a fallback, exec `stty sane` via `exec.Command("stty", "sane")` with stdin attached
     c. Print "Terminal state restored"
   - Import `golang.org/x/term` for terminal state operations

3. Update `internal/cli/root.go`:
   - Replace stub `PersistentPreRunE` with real logic:
     a. If --cleanup flag: call `config.Dir()` to get config dir, then `lifecycle.RunCleanup(configDir)`, then `os.Exit(0)`
     b. If --reset-terminal flag: call `lifecycle.RunResetTerminal()`, then `os.Exit(0)`
   - Add import for `internal/config` and `internal/lifecycle` packages
   - Keep the flag definitions as-is

4. Update `cmd/azad/main.go`:
   - Wrap main execution with signal context:
     a. `ctx, cancel := lifecycle.WithShutdown(context.Background())`
     b. `defer cancel()`
     c. Pass ctx to root command via `rootCmd.SetContext(ctx)` or pass to Execute
   - Add deferred cleanup: on context cancellation, log "Shutting down gracefully..."
   - Keep it simple — the signal context is the foundation that Phase 3 will use for proxy lifecycle

5. Run full verification: `go build`, `go vet`, test each command.

IMPORTANT: For RunResetTerminal, the `stty sane` approach is the crash-recovery fallback. In normal operation (Phase 4 with bubbletea), the TUI framework handles terminal restore. This command is specifically for crash recovery when the terminal is left in raw mode.
  </action>
  <verify>
    <automated>cd /Users/lee/vless-terminal && go build -o azad ./cmd/azad && ./azad --cleanup 2>&1 | grep -qi "clean\|proxy\|state" && ./azad --reset-terminal 2>&1 | grep -qi "terminal\|restore\|state" && go vet ./... && echo "PASS: lifecycle commands work"</automated>
    <manual>1. Run ./azad --cleanup — should report no dirty state. 2. Run ./azad --reset-terminal — should report terminal state restored. 3. Kill the process with Ctrl+C during a long operation — should exit cleanly.</manual>
  </verify>
  <done>Signal handling via context cancellation works (SIGINT/SIGTERM caught). `azad --cleanup` checks for and reports proxy state file status. `azad --reset-terminal` restores terminal with stty sane fallback. `go vet ./...` passes clean.</done>
</task>

</tasks>

<verification>
1. `go build -o azad ./cmd/azad` succeeds
2. `go vet ./...` passes clean
3. `./azad config` shows config file path and default values (socks_port: 1080, http_port: 8080)
4. Manually create `~/.config/azad/config.yaml` with custom port, run `./azad config` — shows custom value
5. `./azad --cleanup` reports clean state (no state file)
6. `./azad --reset-terminal` reports terminal restored
7. Config file created at XDG-compliant path with 0600 permissions
8. Config directory created with 0700 permissions
</verification>

<success_criteria>
- Config persists between runs (write config, restart, read same values)
- XDG path compliance: config lives under os.UserConfigDir()/azad/
- Signal handling catches SIGINT/SIGTERM and triggers context cancellation
- --cleanup is functional (reads state file, reports status)
- --reset-terminal is functional (restores terminal via stty sane)
- No global mutable state in config package (no package-level koanf instance for writes)
- go vet ./... clean
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
