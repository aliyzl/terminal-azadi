---
phase: 05-quick-connect
plan: 02
type: execute
wave: 2
depends_on:
  - "05-01"
files_modified:
  - internal/tui/app.go
  - internal/tui/messages.go
  - internal/tui/connect_cmd.go
autonomous: true
requirements:
  - QCON-01
  - QCON-03

must_haves:
  truths:
    - "Running `azad` with no args launches TUI and auto-connects to last-used or fastest server"
    - "Pressing Enter or c on a server in the TUI initiates a connection to that server"
    - "Quitting TUI while connected stops engine, unsets system proxy, removes state file"
    - "TUI saves LastUsed to config and LastConnected to store after successful connection"
    - "Auto-connect silently skips if server store is empty (no error flash)"
  artifacts:
    - path: "internal/tui/connect_cmd.go"
      provides: "tea.Cmd functions for connect, disconnect, and auto-connect flows"
      contains: "func connectServerCmd"
    - path: "internal/tui/app.go"
      provides: "Init returns auto-connect cmd, Enter/c connects, quit cleans up"
      contains: "autoConnectCmd"
    - path: "internal/tui/messages.go"
      provides: "autoConnectMsg for auto-connect result routing"
      contains: "autoConnectMsg"
  key_links:
    - from: "internal/tui/app.go"
      to: "internal/tui/connect_cmd.go"
      via: "Init returns autoConnectCmd, Enter dispatches connectServerCmd"
      pattern: "connectServerCmd|autoConnectCmd"
    - from: "internal/tui/connect_cmd.go"
      to: "internal/engine/engine.go"
      via: "eng.Start and eng.Stop inside tea.Cmd functions"
      pattern: "eng\\.Start|eng\\.Stop"
    - from: "internal/tui/connect_cmd.go"
      to: "internal/config/config.go"
      via: "config.Save for LastUsed persistence"
      pattern: "config\\.Save"
    - from: "internal/tui/connect_cmd.go"
      to: "internal/serverstore/store.go"
      via: "store.UpdateServer for LastConnected persistence"
      pattern: "store\\.UpdateServer"
---

<objective>
Wire TUI connection lifecycle: auto-connect on startup, manual connect via Enter/c, disconnect + cleanup on quit, and persist preferences after connection.

Purpose: QCON-01 requires the TUI to auto-connect on launch. The TUI currently has no connection capability at all -- Enter only syncs the detail panel. This plan adds the full connection flow as async tea.Cmd functions and wires them into the TUI lifecycle.

Output: New `connect_cmd.go` with connect/disconnect/auto-connect commands; updated `app.go` with Init auto-connect, Enter/c keybinding, and quit cleanup; updated `messages.go` with autoConnectMsg.
</objective>

<execution_context>
@/Users/lee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-quick-connect/05-RESEARCH.md
@.planning/phases/05-quick-connect/05-01-SUMMARY.md
@internal/tui/app.go
@internal/tui/messages.go
@internal/tui/ping.go
@internal/tui/keys.go
@internal/tui/statusbar.go
@internal/cli/connect.go
@internal/engine/engine.go
@internal/config/config.go
@internal/serverstore/store.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TUI connection command functions</name>
  <files>internal/tui/connect_cmd.go, internal/tui/messages.go</files>
  <action>
1. Add `autoConnectMsg` to `internal/tui/messages.go`:
   ```go
   // autoConnectMsg carries the result of the auto-connect attempt on TUI startup.
   type autoConnectMsg struct {
       ServerID string // ID of the server auto-connected to (empty if skipped)
       Err      error  // nil on success, non-nil on failure, nil+empty ID means skipped
   }
   ```

2. Create `internal/tui/connect_cmd.go` with these functions:

   a. `connectServerCmd(srv protocol.Server, eng *engine.Engine, cfg *config.Config, store *serverstore.Store) tea.Cmd`:
      - Returns a `tea.Cmd` that runs the full connection flow in a goroutine.
      - Steps inside the cmd function:
        1. `eng.Start(context.Background(), srv, cfg.Proxy.SOCKSPort, cfg.Proxy.HTTPPort)` -- if error, return `connectResultMsg{Err: err}`
        2. Detect network service: `svc, svcErr := sysproxy.DetectNetworkService()`
        3. If svcErr == nil, call `writeProxyState(svc, cfg.Proxy.SOCKSPort, cfg.Proxy.HTTPPort)` (reuse from cli package -- see note below)
        4. If svcErr == nil, call `sysproxy.SetSystemProxy(svc, cfg.Proxy.SOCKSPort, cfg.Proxy.HTTPPort)` (best-effort, ignore error)
        5. Persist preferences: save `cfg.Server.LastUsed = srv.ID` via `config.Save(cfg, configPath)` where configPath comes from `config.FilePath()`. Update `srv.LastConnected = time.Now()` and call `store.UpdateServer(srv)`. Both best-effort (ignore errors).
        6. Verify IP best-effort: `engine.VerifyIP(cfg.Proxy.SOCKSPort)` (ignore result for now)
        7. Return `connectResultMsg{Err: nil}`
      - For proxy state writing: duplicate the `writeProxyState` and `removeStateFile` helper functions in this file (they are small, 10 lines each, and currently unexported in cli/connect.go). This avoids exporting internal cli helpers or creating a shared package for 2 trivial functions. Name them `tuiWriteProxyState` and `tuiRemoveStateFile` to avoid ambiguity.

   b. `disconnectCmd(eng *engine.Engine) tea.Cmd`:
      - Returns a `tea.Cmd` that:
        1. Detects network service: `svc, svcErr := sysproxy.DetectNetworkService()`
        2. Stops engine: `eng.Stop()` (ignore error)
        3. If svcErr == nil, unsets system proxy: `sysproxy.UnsetSystemProxy(svc)` (best-effort)
        4. Removes state file: `tuiRemoveStateFile()`
        5. Returns `disconnectMsg{}`

   c. `autoConnectCmd(store *serverstore.Store, eng *engine.Engine, cfg *config.Config) tea.Cmd`:
      - Returns a `tea.Cmd` that:
        1. Gets servers via `store.List()`. If empty, return `autoConnectMsg{}` (skip silently -- no error, empty ServerID).
        2. Resolves best server using the same logic as `findServer` in connect.go: try `cfg.Server.LastUsed` via `store.FindByID`, then lowest positive `LatencyMs`, then first server. Inline this ~15 line resolution (do NOT import from cli package -- it would create a circular dependency since cli imports tui).
        3. Calls `eng.Start(context.Background(), *server, cfg.Proxy.SOCKSPort, cfg.Proxy.HTTPPort)`. If error, return `autoConnectMsg{Err: err}`.
        4. Set system proxy + write state (same pattern as connectServerCmd).
        5. Persist LastUsed + LastConnected (same pattern as connectServerCmd).
        6. Return `autoConnectMsg{ServerID: server.ID}`.

   Package imports needed: `context`, `encoding/json`, `os`, `time`, `config`, `engine`, `lifecycle`, `protocol`, `serverstore`, `sysproxy`, `tea`.
  </action>
  <verify>
    <automated>cd /Users/lee/vless-terminal && go build ./...</automated>
    <manual>Verify connect_cmd.go exists with connectServerCmd, disconnectCmd, autoConnectCmd functions</manual>
  </verify>
  <done>Three tea.Cmd functions exist: connectServerCmd (manual connect), disconnectCmd (cleanup), autoConnectCmd (startup). autoConnectMsg added to messages.go.</done>
</task>

<task type="auto">
  <name>Task 2: Wire auto-connect, Enter/c connect, and quit cleanup into TUI model</name>
  <files>internal/tui/app.go</files>
  <action>
1. **Init auto-connect:** Change `Init()` to return `tea.Batch(tickCmd(), autoConnectCmd(m.store, m.engine, m.cfg))`. This fires auto-connect on TUI startup alongside the uptime ticker.

2. **Handle autoConnectMsg:** Add a case in `Update` for `autoConnectMsg`:
   - If `msg.ServerID == ""` (skipped), do nothing (return m, nil).
   - If `msg.Err != nil`, update status bar to show error state briefly (ignore for now -- the connection just won't happen).
   - If success (non-empty ServerID, nil Err):
     - Update status bar: `m.statusBar.Update(engine.StatusConnected, m.engine.ServerName(), m.cfg.Proxy.SOCKSPort)` and `m.statusBar.SetConnectedAt(time.Now())`
     - Auto-select the connected server in the list: iterate `m.serverList` items to find matching ServerID, call `m.serverList.Select(idx)`, then `m.syncDetail()`.

3. **Enter/c connects:** In `handleKeyPress`, `viewNormal` case, change the `"enter"` handler:
   - Instead of just `m.syncDetail()`, get the selected server item and initiate connection:
     ```go
     case "enter", "c":
         if item, ok := m.serverList.SelectedItem().(serverItem); ok {
             m.statusBar.Update(engine.StatusConnecting, item.server.Name, m.cfg.Proxy.SOCKSPort)
             return m, connectServerCmd(item.server, m.engine, m.cfg, m.store)
         }
         return m, nil
     ```
   - If already connected (check `m.engine.Status()` returns `StatusConnected`), disconnect first then reconnect. Use `tea.Sequence(disconnectCmd(m.engine), connectServerCmd(...))` for sequential execution.

4. **Quit cleanup:** In `handleKeyPress`, `viewNormal` case, change the `"q", "ctrl+c"` handler:
   ```go
   case "q", "ctrl+c":
       status, _, _ := m.engine.Status()
       if status == engine.StatusConnected || status == engine.StatusConnecting {
           return m, tea.Sequence(disconnectCmd(m.engine), tea.Quit)
       }
       return m, tea.Quit
   ```
   This ensures system proxy is unset and state file is removed before the TUI exits.

5. **connectResultMsg update:** The existing `connectResultMsg` handler already updates status bar. Add a `m.syncDetail()` call and auto-select the connected server in the list (find the item whose server matches the engine's current server and select it). This ensures the detail panel shows the connected server after auto-connect.
  </action>
  <verify>
    <automated>cd /Users/lee/vless-terminal && go build ./... && go vet ./...</automated>
    <manual>Verify: Init returns tea.Batch with autoConnectCmd; Enter/c dispatches connectServerCmd; q/ctrl+c cleans up before quit</manual>
  </verify>
  <done>TUI auto-connects on launch, Enter/c connects to selected server, quit cleans up engine + proxy + state file. LastUsed and LastConnected persist from both TUI and headless paths.</done>
</task>

</tasks>

<verification>
- `go build ./...` compiles without errors
- `go vet ./...` reports no issues
- `Init()` returns `tea.Batch(tickCmd(), autoConnectCmd(...))`
- `Enter`/`c` key in viewNormal dispatches `connectServerCmd`
- `q`/`ctrl+c` in viewNormal cleans up via `disconnectCmd` before `tea.Quit`
- `autoConnectMsg` handled: skips silently if empty store, updates status bar on success
- `connectResultMsg` updates status bar and syncs detail panel
- `connect_cmd.go` contains `connectServerCmd`, `disconnectCmd`, `autoConnectCmd`
</verification>

<success_criteria>
- TUI launches and auto-connects to last-used or fastest server without user interaction
- Enter/c in server list initiates connection with visual feedback (Connecting state)
- Quitting while connected properly cleans up proxy and state
- Preferences persist: LastUsed in config.yaml, LastConnected in servers.json
- Empty server store results in normal TUI display with no error flash
</success_criteria>

<output>
After completion, create `.planning/phases/05-quick-connect/05-02-SUMMARY.md`
</output>
