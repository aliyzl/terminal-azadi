---
phase: 08-split-tunneling
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - internal/splittunnel/rule.go
  - internal/splittunnel/rule_test.go
  - internal/splittunnel/xray.go
  - internal/splittunnel/xray_test.go
  - internal/config/config.go
  - internal/engine/config.go
  - internal/engine/config_test.go
autonomous: true
requirements:
  - SPLT-01
  - SPLT-02
  - SPLT-03

must_haves:
  truths:
    - "IP addresses (single and CIDR) are validated and classified correctly"
    - "Hostnames and wildcard domains are validated and classified correctly"
    - "Invalid rule inputs produce clear error messages"
    - "Exclusive mode routes listed rules to direct outbound, unmatched to proxy"
    - "Inclusive mode routes listed rules to proxy outbound, unmatched to direct"
    - "Domain rules change domainStrategy to IPIfNonMatch"
    - "User split tunnel rules are placed before geoip:private rule"
    - "Config struct persists split tunnel rules and mode via koanf"
  artifacts:
    - path: "internal/splittunnel/rule.go"
      provides: "Rule struct, RuleType enum, ParseRule validation, Mode type"
      exports: ["Rule", "RuleType", "RuleTypeIP", "RuleTypeCIDR", "RuleTypeDomain", "RuleTypeWildcard", "Mode", "ModeExclusive", "ModeInclusive", "ParseRule", "HasDomainRules"]
    - path: "internal/splittunnel/xray.go"
      provides: "ToXrayRules converting split tunnel rules to Xray RoutingRule format"
      exports: ["ToXrayRules", "Config"]
    - path: "internal/config/config.go"
      provides: "SplitTunnelConfig and SplitTunnelRule types in Config struct"
      contains: "SplitTunnel"
    - path: "internal/engine/config.go"
      provides: "BuildConfig accepts optional split tunnel config and injects routing rules"
      contains: "splittunnel"
  key_links:
    - from: "internal/splittunnel/xray.go"
      to: "internal/engine/config.go"
      via: "ToXrayRules called in BuildConfig"
      pattern: "splittunnel\\.ToXrayRules"
    - from: "internal/config/config.go"
      to: "internal/splittunnel/rule.go"
      via: "SplitTunnelRule mirrors splittunnel.Rule for persistence"
      pattern: "SplitTunnelRule"
    - from: "internal/engine/config.go"
      to: "RoutingRule"
      via: "Domain field added to RoutingRule struct"
      pattern: "Domain.*\\[\\]string"
---

<objective>
Create the splittunnel package with rule parsing/validation and Xray routing rule generation, extend Config for persistence, and integrate into BuildConfig for inclusive/exclusive routing modes.

Purpose: This is the core split tunneling data layer -- rule types, validation, Xray translation, and config persistence. All downstream plans (CLI, TUI, kill switch coordination) depend on these types and BuildConfig integration.
Output: Working splittunnel package with TDD tests, Config struct with SplitTunnel section, BuildConfig accepting split tunnel rules.
</objective>

<execution_context>
@/Users/lee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-split-tunneling/08-RESEARCH.md
@.planning/phases/03-connection-engine/03-01-SUMMARY.md

Key codebase files:
@internal/engine/config.go
@internal/engine/config_test.go
@internal/config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD RED - Failing tests for rule parsing, Xray translation, and BuildConfig integration</name>
  <files>
    internal/splittunnel/rule_test.go
    internal/splittunnel/xray_test.go
    internal/engine/config_test.go
  </files>
  <action>
Create test files that define expected behavior before implementation.

**internal/splittunnel/rule_test.go:**
Table-driven tests for ParseRule covering:
- Valid single IP: "1.2.3.4" -> RuleTypeIP
- Valid CIDR: "10.0.0.0/8" -> RuleTypeCIDR
- Valid CIDR: "192.168.1.0/24" -> RuleTypeCIDR
- Valid domain: "example.com" -> RuleTypeDomain
- Valid domain: "sub.example.com" -> RuleTypeDomain
- Valid wildcard: "*.google.com" -> RuleTypeWildcard
- Invalid: empty string -> error
- Invalid: "not a rule at all" -> error
- Invalid wildcard: "*.." -> error
- Whitespace trimming: "  1.2.3.4  " -> RuleTypeIP
- IPv6 single IP: "::1" -> RuleTypeIP
- IPv6 CIDR: "fd00::/8" -> RuleTypeCIDR

Test HasDomainRules:
- Returns true when rules contain RuleTypeDomain or RuleTypeWildcard
- Returns false when rules contain only RuleTypeIP and RuleTypeCIDR

**internal/splittunnel/xray_test.go:**
Table-driven tests for ToXrayRules covering:
- Exclusive mode: domain rule -> outboundTag "direct", uses "full:" + "domain:" prefixes
- Exclusive mode: IP rule -> outboundTag "direct", in ip array
- Exclusive mode: wildcard -> outboundTag "direct", uses "domain:" prefix (strip "*.")
- Inclusive mode: domain rule -> outboundTag "proxy"
- Mixed IP + domain rules -> separate RoutingRule entries (one for domains, one for IPs)
- Empty rules -> empty result

Import `internal/engine` package for RoutingRule type reference. The xray.go ToXrayRules function should return `[]engine.RoutingRule`.

**internal/engine/config_test.go:**
Add new tests (do NOT delete existing tests) for BuildConfig with split tunnel:
- Exclusive mode with domain rule: routing rules contain user rule before geoip:private, domainStrategy = "IPIfNonMatch", outbound order = [proxy, direct]
- Inclusive mode with IP rule: first outbound is direct (freedom), domainStrategy = "AsIs" (IP-only), user rule has outboundTag "proxy"
- Nil split config: behaves exactly as before (regression test)

Note: RoutingRule struct needs a `Domain []string` field added (currently only has IP). Add this expectation in the test. Tests will fail to compile initially -- that's the RED state.
  </action>
  <verify>
    <automated>cd /Users/lee/vless-terminal && go test ./internal/splittunnel/... ./internal/engine/... 2>&1 | head -50</automated>
    <manual>Tests should fail (RED state) -- compilation errors or assertion failures expected</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>Test files exist with comprehensive table-driven tests. Tests fail (RED) because implementation does not yet exist.</done>
</task>

<task type="auto">
  <name>Task 2: TDD GREEN - Implement splittunnel package, Config extension, and BuildConfig integration</name>
  <files>
    internal/splittunnel/rule.go
    internal/splittunnel/xray.go
    internal/config/config.go
    internal/engine/config.go
  </files>
  <action>
Implement the minimum code to make all tests pass.

**internal/splittunnel/rule.go:**
Create the splittunnel package with:
- `RuleType` string enum: `RuleTypeIP`, `RuleTypeCIDR`, `RuleTypeDomain`, `RuleTypeWildcard`
- `Rule` struct with `Value string` and `Type RuleType` (koanf + yaml tags)
- `Mode` string type with `ModeExclusive = "exclusive"` and `ModeInclusive = "inclusive"`
- `Config` struct with `Enabled bool`, `Mode Mode`, `Rules []Rule` (this is the runtime config, distinct from the persistence config in config/config.go)
- `ParseRule(input string) (Rule, error)` function:
  1. `strings.TrimSpace(input)`
  2. Try `net.ParseIP` -> RuleTypeIP
  3. Try `net.ParseCIDR` -> RuleTypeCIDR
  4. Try wildcard: `strings.HasPrefix(input, "*.")` then validate domain part with `isValidDomain`
  5. Try plain domain with `isValidDomain`
  6. Error with descriptive message
- `isValidDomain(s string) bool`: at least one dot, no leading/trailing dot, only alphanumeric + hyphen + dots, each label non-empty
- `HasDomainRules(rules []Rule) bool`: returns true if any rule is RuleTypeDomain or RuleTypeWildcard

**internal/splittunnel/xray.go:**
- `ToXrayRules(rules []Rule, mode Mode) []engine.RoutingRule`:
  - Collect domains and IPs separately
  - For RuleTypeDomain: add both `"full:" + value` AND `"domain:" + value` (matches exact + subdomains, per research pitfall 5)
  - For RuleTypeWildcard: add `"domain:" + strings.TrimPrefix(value, "*.")` (subdomains only)
  - For RuleTypeIP/RuleTypeCIDR: add value directly to IP list
  - Determine outboundTag: exclusive -> "direct", inclusive -> "proxy"
  - Return separate RoutingRule entries for domains and IPs (if non-empty)

**internal/config/config.go:**
Add to Config struct:
```go
SplitTunnel SplitTunnelConfig `koanf:"split_tunnel"`
```
Add types:
```go
type SplitTunnelConfig struct {
    Enabled bool              `koanf:"enabled"`
    Mode    string            `koanf:"mode"`
    Rules   []SplitTunnelRule `koanf:"rules"`
}
type SplitTunnelRule struct {
    Value string `koanf:"value"`
    Type  string `koanf:"type"`
}
```
No changes to Defaults(), Load(), or Save() -- koanf handles zero values automatically.

**internal/engine/config.go:**
1. Add `Domain []string` field to `RoutingRule` struct: `Domain []string \`json:"domain,omitempty"\``
2. Change `BuildConfig` signature to accept optional split tunnel config:
   `func BuildConfig(srv protocol.Server, socksPort, httpPort int, splitCfg *splittunnel.Config) (*XrayConfig, *core.Config, error)`
   - Import `"github.com/leejooy96/azad/internal/splittunnel"`
3. When `splitCfg != nil && splitCfg.Enabled && splitCfg.Mode == splittunnel.ModeInclusive`:
   - Swap outbound order: `[{Tag: "direct", Protocol: "freedom"}, outbound]`
4. Build routing rules array:
   - If splitCfg enabled with rules: prepend `splittunnel.ToXrayRules(...)` before geoip:private
   - If splitCfg has domain rules: set domainStrategy to "IPIfNonMatch"
5. geoip:private -> direct always last (safety net)

**CRITICAL:** Update ALL existing callers of BuildConfig to pass `nil` for the new parameter. Grep for `BuildConfig(` to find them:
- `internal/engine/engine.go` line ~73: `BuildConfig(srv, socksPort, httpPort)` -> add `nil` as 4th arg
- Any test files calling BuildConfig: add `nil` as 4th arg

Do NOT break existing tests. The nil path must produce identical output to the current implementation.
  </action>
  <verify>
    <automated>cd /Users/lee/vless-terminal && go test ./internal/splittunnel/... ./internal/engine/... -v -count=1 2>&1 | tail -30</automated>
    <manual>All tests pass (GREEN state), including both new split tunnel tests and existing engine tests</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>All tests pass. ParseRule correctly classifies IP, CIDR, domain, wildcard inputs. ToXrayRules produces correct Xray routing rules for exclusive and inclusive modes. BuildConfig injects split tunnel routing rules with correct outbound ordering and domainStrategy. Existing BuildConfig behavior unchanged when splitCfg is nil.</done>
</task>

</tasks>

<verification>
1. `go test ./internal/splittunnel/... -v` -- all rule parsing and Xray translation tests pass
2. `go test ./internal/engine/... -v` -- all existing config builder tests still pass + new split tunnel tests pass
3. `go build ./...` -- entire project compiles with no errors
4. `go vet ./internal/splittunnel/ ./internal/engine/ ./internal/config/` -- no vet issues
</verification>

<success_criteria>
- splittunnel package exists with Rule, RuleType, Mode, Config types
- ParseRule validates and classifies all rule types (IP, CIDR, domain, wildcard)
- ToXrayRules translates rules to Xray RoutingRule format with correct outbound tags
- Config struct has SplitTunnel section for YAML persistence
- BuildConfig accepts split tunnel config and injects routing rules
- Inclusive mode swaps outbound ordering (direct first)
- Domain rules trigger domainStrategy "IPIfNonMatch"
- User rules placed before geoip:private (higher priority)
- All existing tests continue to pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/08-split-tunneling/08-01-SUMMARY.md`
</output>
