---
phase: 04-tui-and-server-interaction
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - internal/tui/app.go
  - internal/tui/help.go
  - internal/cli/root.go
autonomous: true
requirements: [TUI-01, TUI-02, TUI-03, TUI-05, TUI-06]

must_haves:
  truths:
    - "App displays split-pane layout with server list on left, detail panel on right, status bar at bottom"
    - "User navigates server list with j/k, selects with Enter, quits with q, goes back with Esc"
    - "User can fuzzy-filter servers by pressing / and typing a search query"
    - "User sees help overlay with all keybindings when pressing ?"
    - "Layout adapts to terminal size and shows minimum-size message if too small"
    - "Running azad with no subcommand launches the TUI"
  artifacts:
    - path: "internal/tui/app.go"
      provides: "Root model with Init/Update/View, child composition, layout, focus management"
      contains: "func New("
    - path: "internal/tui/help.go"
      provides: "Help overlay toggled by ? key"
      contains: "helpModel"
    - path: "internal/cli/root.go"
      provides: "Root command RunE launches TUI when no subcommand given"
      contains: "tui.New("
  key_links:
    - from: "internal/tui/app.go"
      to: "internal/tui/serverlist.go"
      via: "root model owns server list child model"
      pattern: "m\\.serverList"
    - from: "internal/tui/app.go"
      to: "internal/tui/statusbar.go"
      via: "root model owns status bar child model"
      pattern: "m\\.statusBar"
    - from: "internal/tui/app.go"
      to: "internal/tui/detail.go"
      via: "root model owns detail child model"
      pattern: "m\\.detail"
    - from: "internal/cli/root.go"
      to: "internal/tui/app.go"
      via: "root command launches TUI program"
      pattern: "tea\\.NewProgram"
---

<objective>
Create the root TUI model that composes all child components into a split-pane layout with keyboard navigation, help overlay, and wire it as the default command when running `azad` without arguments.

Purpose: This is the interactive shell that brings all visual components together into a working TUI application. After this plan, users can launch the TUI, see their servers, navigate the list, view details, and access help.

Output: Working TUI application launchable via `azad` command.
</objective>

<execution_context>
@/Users/lee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-tui-and-server-interaction/04-RESEARCH.md
@.planning/phases/04-tui-and-server-interaction/04-01-SUMMARY.md

@internal/tui/theme.go
@internal/tui/keys.go
@internal/tui/messages.go
@internal/tui/serverlist.go
@internal/tui/detail.go
@internal/tui/statusbar.go
@internal/cli/root.go
@internal/config/config.go
@internal/engine/engine.go
@internal/serverstore/store.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create root model with split-pane layout and navigation</name>
  <files>internal/tui/app.go</files>
  <action>
Create `internal/tui/app.go` implementing the Bubble Tea v2 Model interface.

Define view state enum:
```go
type viewState int
const (
    viewNormal viewState = iota
    viewHelp
    viewAddServer
    viewAddSubscription
    viewConfirmDelete
)
```

Define minimum terminal dimensions: `const minWidth, minHeight = 60, 20`
Define status bar height: `const statusBarHeight = 1`

Define the root model struct:
```go
type model struct {
    // Child models
    serverList  list.Model
    detail      detailModel
    statusBar   statusBarModel
    help        helpModel
    keys        keyMap

    // State
    view        viewState
    width       int
    height      int
    ready       bool

    // Shared references
    store       *serverstore.Store
    engine      *engine.Engine
    cfg         *config.Config
}
```

Create `New(store *serverstore.Store, eng *engine.Engine, cfg *config.Config) model` constructor:
- Load servers from store, convert to list items via `serversToItems()`
- Create server list via `newServerList(items, 0, 0)` (dimensions set on first WindowSizeMsg)
- Initialize child models (detail, statusBar, help, keys)
- Initialize engine status from `eng.Status()`
- Return configured model

Implement `Init() tea.Cmd`:
- Return `tickCmd()` to start the uptime ticker (define `tickCmd` as `tea.Tick(time.Second, func(t time.Time) tea.Msg { return tickMsg(t) })`)

Implement `Update(msg tea.Msg) (tea.Model, tea.Cmd)`:

Handle global messages first (regardless of view state):
- `tea.WindowSizeMsg`: Set m.width/m.height, m.ready=true, recalculate and call SetSize on all children:
  - List width = m.width/3, list height = m.height - statusBarHeight
  - Detail width = m.width - listWidth - 1 (for border), detail height = m.height - statusBarHeight
  - Status bar width = m.width
- `tickMsg`: If connected, update statusBar view, return next tickCmd()
- `pingResultMsg`, `allPingsCompleteMsg`: Update server latency in store, update list items (delegate to handler methods)
- `connectResultMsg`, `disconnectMsg`: Update status bar, detail panel
- `errMsg`: Could show in status bar or as notification

Handle `tea.KeyPressMsg` (NOTE: KeyPressMsg not KeyMsg — v2 breaking change):

When `m.view == viewNormal`:
- `q`, `ctrl+c`: Return `tea.Quit`
- `?`: Set `m.view = viewHelp`, return nil
- `enter`: Get selected server from list, initiate connection (for now, just update detail panel with selected server)
- `esc`: If list is filtering, let list handle it. Otherwise no-op.
- Route all other keys to `m.serverList.Update(msg)` — this handles j/k, /, filtering internally

When `m.view == viewHelp`:
- `?`, `esc`, `q`: Set `m.view = viewNormal`, return nil

When `m.view == viewAddServer` or `viewAddSubscription`:
- Delegate to input model (implemented in Plan 03). For now, `esc` returns to viewNormal.

After key handling in viewNormal, sync the detail panel:
- Get selected item from list: `if item, ok := m.serverList.SelectedItem().(serverItem); ok { m.detail.SetServer(&item.server) }`

Implement `View() tea.View` (NOTE: returns tea.View not string — v2 breaking change):

- If `!m.ready`: return `tea.NewView("Initializing...")`
- If terminal too small: return `tea.NewView("Terminal too small. Resize to at least 60x20.")`
- Calculate panel dimensions:
  - listWidth = m.width / 3
  - detailWidth = m.width - listWidth - 1
  - contentHeight = m.height - statusBarHeight
- Style list panel: `lipgloss.NewStyle().Width(listWidth).Height(contentHeight).BorderRight(true).BorderStyle(lipgloss.NormalBorder()).BorderForeground(DefaultTheme.Border)`
- Style detail panel: `lipgloss.NewStyle().Width(detailWidth).Height(contentHeight)`
- Compose: `listPanel := listStyle.Render(m.serverList.View())` — NOTE: child View() returns string, only root returns tea.View
- Compose: `detailPanel := detailStyle.Render(m.detail.View())`
- Join horizontally: `main := lipgloss.JoinHorizontal(lipgloss.Top, listPanel, detailPanel)`
- Join with status bar: `content := lipgloss.JoinVertical(lipgloss.Left, main, m.statusBar.View())`
- If help overlay active: `content = m.help.Render(content, m.width, m.height)` (overlay on top)
- Wrap: `v := tea.NewView(content); v.AltScreen = true; return v`

CRITICAL v2 API notes:
- `View()` returns `tea.View`, not `string`. Use `tea.NewView(contentString)` to wrap.
- Set `v.AltScreen = true` on the View struct, NOT via `tea.WithAltScreen()` program option.
- Key messages are `tea.KeyPressMsg`, NOT `tea.KeyMsg`.
- Space bar matches `"space"`, NOT `" "`.
- `m.serverList.View()` returns `string` (child components still return string in v2).
  </action>
  <verify>
    <automated>cd /Users/lee/vless-terminal && go build ./internal/tui/...</automated>
    <manual>Verify app.go has New constructor, Init, Update, View methods. Check that View returns tea.View with AltScreen=true.</manual>
  </verify>
  <done>Root model composes server list, detail panel, and status bar into split-pane layout. Navigation with j/k/enter/esc/q works. WindowSizeMsg resizes all children. Help overlay toggles with ?. Minimum size check shows fallback message.</done>
</task>

<task type="auto">
  <name>Task 2: Create help overlay and wire TUI launch from CLI</name>
  <files>internal/tui/help.go, internal/cli/root.go</files>
  <action>
Create `internal/tui/help.go`:

Define `helpModel` struct:
- Fields: `help help.Model`, `keys keyMap`
- Constructor: `newHelpModel(keys keyMap) helpModel` — creates help.Model, sets keys

Implement `Render(content string, width, height int) string` method:
- Create a centered box overlay on top of the existing content
- Generate help text from `m.help.FullHelpView(m.keys.FullHelp())`
- Style the help text in a bordered box: `lipgloss.NewStyle().Border(lipgloss.RoundedBorder()).BorderForeground(DefaultTheme.Accent).Padding(1, 2).Width(maxHelpWidth)`
- Use `lipgloss.Place(width, height, lipgloss.Center, lipgloss.Center, helpBox)` to center the overlay
- The overlay replaces the content (not transparent overlay — full repaint with help in center)

Modify `internal/cli/root.go`:

Update the `RunE` function of the root command to launch the TUI instead of showing help:

```go
RunE: func(cmd *cobra.Command, args []string) error {
    // Load config
    configPath, err := config.FilePath()
    if err != nil {
        return fmt.Errorf("resolving config path: %w", err)
    }
    cfg, err := config.Load(configPath)
    if err != nil {
        return fmt.Errorf("loading config: %w", err)
    }

    // Load server store
    dataDir, err := config.DataDir()
    if err != nil {
        return fmt.Errorf("resolving data dir: %w", err)
    }
    storePath := filepath.Join(dataDir, "servers.json")
    store := serverstore.New(storePath)
    if err := store.Load(); err != nil {
        return fmt.Errorf("loading servers: %w", err)
    }

    // Create engine
    eng := &engine.Engine{}

    // Launch TUI
    m := tui.New(store, eng, cfg)
    p := tea.NewProgram(m)
    _, err = p.Run()
    return err
}
```

Add imports for:
- `charm.land/bubbletea/v2` (aliased as `tea`)
- `"github.com/leejooy96/azad/internal/tui"`
- `"github.com/leejooy96/azad/internal/engine"`
- `"github.com/leejooy96/azad/internal/serverstore"`
- `"path/filepath"`

Remove the old `cmd.Help()` return from RunE.

Keep the `--cleanup` and `--reset-terminal` flags and PersistentPreRunE unchanged — they still intercept before RunE.

Keep the subcommand registrations (connect, servers, config) — when a subcommand is provided, cobra routes to it instead of root RunE.
  </action>
  <verify>
    <automated>cd /Users/lee/vless-terminal && go build ./cmd/azad/...</automated>
    <manual>Run `go run ./cmd/azad/ --help` to verify help still works. Verify that running without args would launch TUI (don't actually run it in CI — it needs a terminal).</manual>
  </verify>
  <done>Help overlay renders a centered bordered box with all keybindings from FullHelp. Root command RunE launches the TUI program. `azad` with no args starts the interactive interface. Subcommands and flags still work.</done>
</task>

</tasks>

<verification>
Full project builds without errors:
```bash
cd /Users/lee/vless-terminal && go build ./...
```

Verify TUI package compiles:
```bash
cd /Users/lee/vless-terminal && go vet ./internal/tui/...
```

Run existing tests to confirm no regressions:
```bash
cd /Users/lee/vless-terminal && go test ./...
```
</verification>

<success_criteria>
- app.go implements tea.Model interface (Init, Update, View returning tea.View)
- Split-pane layout composes list panel + detail panel + status bar
- j/k/enter/esc/q navigation routed correctly
- / activates list fuzzy filtering (via bubbles/list built-in)
- ? toggles help overlay with centered keybinding display
- WindowSizeMsg resizes all children, minimum-size guard active
- `azad` (no args) launches TUI; `azad connect`, `azad servers`, `azad config` still work
- `go build ./...` and `go test ./...` pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-tui-and-server-interaction/04-02-SUMMARY.md`
</output>
