---
phase: 08-split-tunneling
plan: 02
type: execute
wave: 2
depends_on:
  - "08-01"
files_modified:
  - internal/killswitch/rules.go
  - internal/engine/engine.go
  - internal/cli/split_tunnel.go
  - internal/cli/connect.go
  - internal/cli/root.go
autonomous: true
requirements:
  - SPLT-05
  - SPLT-06

must_haves:
  truths:
    - "GenerateRules accepts bypass IPs for split tunnel direct destinations"
    - "Engine.Start accepts split tunnel config and passes it to BuildConfig"
    - "azad split-tunnel add/remove/list/mode/enable/disable/clear subcommands work correctly"
    - "azad connect passes split tunnel config from config file to engine"
    - "Kill switch pf rules allow direct traffic to bypass IPs when split tunnel is active"
  artifacts:
    - path: "internal/killswitch/rules.go"
      provides: "GenerateRules with bypass IPs parameter"
      contains: "bypassIPs"
    - path: "internal/engine/engine.go"
      provides: "Engine.Start accepts split tunnel config"
      contains: "splittunnel"
    - path: "internal/cli/split_tunnel.go"
      provides: "azad split-tunnel subcommand with add/remove/list/mode/enable/disable/clear"
      exports: ["newSplitTunnelCmd"]
    - path: "internal/cli/connect.go"
      provides: "Connect flow loads and passes split tunnel config"
      contains: "SplitTunnel"
  key_links:
    - from: "internal/cli/connect.go"
      to: "internal/engine/engine.go"
      via: "Engine.Start receives split tunnel config"
      pattern: "eng\\.Start.*split"
    - from: "internal/killswitch/rules.go"
      to: "internal/cli/connect.go"
      via: "Connect passes bypass IPs to kill switch Enable"
      pattern: "bypassIPs|BypassIPs"
    - from: "internal/cli/split_tunnel.go"
      to: "internal/config/config.go"
      via: "CLI reads/writes SplitTunnelConfig"
      pattern: "cfg\\.SplitTunnel"
---

<objective>
Wire split tunneling into the engine lifecycle, kill switch coordination, and CLI management commands.

Purpose: Connect the split tunnel data layer (Plan 01) to the runtime engine, coordinate with kill switch firewall rules, and provide CLI management for rule CRUD and mode switching.
Output: Engine.Start accepts split tunnel config, kill switch pf rules allow bypass IPs, CLI subcommand manages rules.
</objective>

<execution_context>
@/Users/lee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-split-tunneling/08-RESEARCH.md
@.planning/phases/08-split-tunneling/08-01-SUMMARY.md
@.planning/phases/07-kill-switch/07-01-SUMMARY.md

Key codebase files:
@internal/killswitch/rules.go
@internal/killswitch/killswitch.go
@internal/engine/engine.go
@internal/cli/connect.go
@internal/cli/root.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Kill switch coordination and Engine.Start split tunnel wiring</name>
  <files>
    internal/killswitch/rules.go
    internal/engine/engine.go
  </files>
  <action>
**internal/killswitch/rules.go:**
Modify `GenerateRules` signature to accept bypass IPs for split tunnel coordination:
```go
func GenerateRules(serverIP string, serverPort int, bypassIPs []string) string
```
- After the VPN server pass rule and before the block rules, add a loop:
```go
for _, ip := range bypassIPs {
    // Pass direct split tunnel traffic through the firewall
    builder.WriteString(fmt.Sprintf("pass out quick from any to %s\n", ip))
}
```
- This allows traffic destined for split tunnel bypass IPs to exit the machine directly even when kill switch is active.
- For CIDR ranges in bypassIPs, pf handles CIDR notation natively (e.g., `pass out quick from any to 10.0.0.0/8`).
- Update all callers of GenerateRules to pass `nil` or `[]string{}` for bypassIPs. Grep for `GenerateRules(` -- it's called in `internal/killswitch/killswitch.go` Enable function. Update that call.

**internal/killswitch/killswitch.go:**
Update Enable function signature to accept bypass IPs:
```go
func Enable(serverIP string, serverPort int, bypassIPs ...[]string) error
```
Use variadic so existing callers don't break. Inside: `var bypass []string; if len(bypassIPs) > 0 { bypass = bypassIPs[0] }`. Pass `bypass` to `GenerateRules`.

**internal/engine/engine.go:**
Modify `Engine.Start` to accept split tunnel config:
```go
func (e *Engine) Start(ctx context.Context, srv protocol.Server, socksPort, httpPort int, splitCfg ...*splittunnel.Config) error
```
Use variadic for backwards compatibility. Inside: extract splitCfg if provided, pass to BuildConfig.
```go
var sc *splittunnel.Config
if len(splitCfg) > 0 {
    sc = splitCfg[0]
}
_, coreConfig, err := BuildConfig(srv, socksPort, httpPort, sc)
```
Import `"github.com/leejooy96/azad/internal/splittunnel"`.
  </action>
  <verify>
    <automated>cd /Users/lee/vless-terminal && go build ./... && go vet ./internal/killswitch/ ./internal/engine/</automated>
    <manual>Project compiles. All existing callers of Engine.Start and GenerateRules still work without changes (variadic compatibility).</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>GenerateRules accepts bypass IPs and injects pf pass rules for split tunnel direct traffic. Engine.Start accepts optional split tunnel config and passes it through to BuildConfig. All existing callers compile without modification.</done>
</task>

<task type="auto">
  <name>Task 2: CLI split-tunnel subcommand and connect wiring</name>
  <files>
    internal/cli/split_tunnel.go
    internal/cli/connect.go
    internal/cli/root.go
  </files>
  <action>
**internal/cli/split_tunnel.go:**
Create new file with cobra subcommand structure following existing patterns (see cli/servers.go for reference). Import splittunnel, config packages.

```go
func newSplitTunnelCmd() *cobra.Command {
    cmd := &cobra.Command{
        Use:     "split-tunnel",
        Short:   "Manage split tunnel rules",
        Aliases: []string{"st"},
    }
    cmd.AddCommand(
        newSTAddCmd(),
        newSTRemoveCmd(),
        newSTListCmd(),
        newSTModeCmd(),
        newSTEnableCmd(),
        newSTDisableCmd(),
        newSTClearCmd(),
    )
    return cmd
}
```

Subcommands:
- `add <rule>`: ParseRule, check for duplicate, append to cfg.SplitTunnel.Rules, Save config. Print "Added {type} rule: {value}".
- `remove <rule>`: Find and remove matching rule by value, Save. Print "Removed rule: {value}" or error if not found.
- `list`: Print current mode, enabled status, and all rules with type annotations. "No rules configured" if empty.
- `mode <exclusive|inclusive>`: Set cfg.SplitTunnel.Mode, Save. Print "Split tunnel mode set to {mode}".
- `enable`: Set cfg.SplitTunnel.Enabled = true, Save. Print "Split tunneling enabled" + warning "Reconnect required for changes to take effect" if no rules exist.
- `disable`: Set cfg.SplitTunnel.Enabled = false, Save. Print "Split tunneling disabled".
- `clear`: Remove all rules, Save. Print "All split tunnel rules cleared".

Each subcommand loads config via config.Load/config.Save pattern. Convert between config.SplitTunnelRule and splittunnel.Rule when calling ParseRule.

Default mode: If cfg.SplitTunnel.Mode is empty, treat as "exclusive" (bypass list).

**internal/cli/root.go:**
Add `newSplitTunnelCmd()` to root command's AddCommand list (find the existing `cmd.AddCommand(...)` call that registers connect, servers, config commands).

**internal/cli/connect.go:**
In `runConnect`, after loading config and before engine start:
1. Build split tunnel runtime config from cfg.SplitTunnel:
```go
var splitCfg *splittunnel.Config
if cfg.SplitTunnel.Enabled && len(cfg.SplitTunnel.Rules) > 0 {
    mode := splittunnel.ModeExclusive
    if cfg.SplitTunnel.Mode == "inclusive" {
        mode = splittunnel.ModeInclusive
    }
    var rules []splittunnel.Rule
    for _, r := range cfg.SplitTunnel.Rules {
        rules = append(rules, splittunnel.Rule{Value: r.Value, Type: splittunnel.RuleType(r.Type)})
    }
    splitCfg = &splittunnel.Config{Enabled: true, Mode: mode, Rules: rules}
}
```
2. Pass splitCfg to `eng.Start(ctx, *server, cfg.Proxy.SOCKSPort, cfg.Proxy.HTTPPort, splitCfg)`
3. When kill switch is enabled AND split tunnel is active in exclusive mode, extract bypass IPs from split tunnel rules for pf coordination:
```go
var bypassIPs []string
if splitCfg != nil && splitCfg.Mode == splittunnel.ModeExclusive {
    for _, r := range splitCfg.Rules {
        switch r.Type {
        case splittunnel.RuleTypeIP, splittunnel.RuleTypeCIDR:
            bypassIPs = append(bypassIPs, r.Value)
        case splittunnel.RuleTypeDomain, splittunnel.RuleTypeWildcard:
            // Resolve domain to IP for pf bypass (best-effort)
            domain := r.Value
            if r.Type == splittunnel.RuleTypeWildcard {
                domain = strings.TrimPrefix(domain, "*.")
            }
            if ips, err := net.LookupHost(domain); err == nil {
                bypassIPs = append(bypassIPs, ips...)
            }
        }
    }
}
```
4. Pass bypassIPs to `killswitch.Enable(resolvedIP, server.Port, bypassIPs)` when kill switch flag is set.
5. Print split tunnel status after connection: "Split tunneling: {mode} mode with {N} rules"
  </action>
  <verify>
    <automated>cd /Users/lee/vless-terminal && go build ./... && go vet ./internal/cli/</automated>
    <manual>Project compiles. `go run ./cmd/azad split-tunnel --help` shows subcommands. `go run ./cmd/azad split-tunnel list` shows empty rules.</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>CLI split-tunnel subcommand registered with add/remove/list/mode/enable/disable/clear operations. Connect flow loads split tunnel config, passes to engine, and coordinates bypass IPs with kill switch. All existing connect behavior preserved when split tunnel is disabled.</done>
</task>

</tasks>

<verification>
1. `go build ./...` -- entire project compiles
2. `go test ./internal/killswitch/... ./internal/engine/...` -- existing tests pass
3. `go vet ./...` -- no vet issues across project
4. `go run ./cmd/azad split-tunnel list` -- shows "No rules configured"
5. `go run ./cmd/azad split-tunnel add 10.0.0.0/8` -- adds CIDR rule
6. `go run ./cmd/azad split-tunnel add "*.google.com"` -- adds wildcard rule
7. `go run ./cmd/azad split-tunnel list` -- shows both rules with types
8. `go run ./cmd/azad split-tunnel mode inclusive` -- switches mode
9. `go run ./cmd/azad split-tunnel remove 10.0.0.0/8` -- removes rule
10. `go run ./cmd/azad split-tunnel clear` -- removes all rules
</verification>

<success_criteria>
- GenerateRules accepts and injects bypass IPs into pf rules
- Engine.Start accepts split tunnel config (backwards-compatible variadic)
- CLI split-tunnel subcommand with all CRUD operations working
- Connect flow passes split tunnel config to engine and kill switch
- Bypass IPs extracted from exclusive mode rules for pf coordination
- Domain rules resolved to IPs for pf bypass (best-effort)
- All existing tests and behavior unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/08-split-tunneling/08-02-SUMMARY.md`
</output>
