---
phase: 06-distribution
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/geoasset/geoasset.go
  - internal/geoasset/geoasset_test.go
  - internal/engine/engine.go
  - internal/lifecycle/cleanup.go
autonomous: true
requirements:
  - DIST-02
  - DIST-03

must_haves:
  truths:
    - "On first run with missing geoip.dat/geosite.dat, app downloads them automatically before connecting"
    - "Downloaded geo files are verified against SHA256 checksums before being used"
    - "Recovery commands (--cleanup, --reset-terminal) work on Linux without crashing on macOS-only system calls"
    - "On Linux, cleanup skips system proxy unset (SOCKS proxy is app-level) and prints message for unsupported kill switch cleanup"
  artifacts:
    - path: "internal/geoasset/geoasset.go"
      provides: "Geo asset download, SHA256 verification, atomic write"
      exports: ["EnsureAssets"]
    - path: "internal/geoasset/geoasset_test.go"
      provides: "Unit tests for geo asset download with HTTP mock"
      contains: "httptest.NewServer"
    - path: "internal/engine/engine.go"
      provides: "Pre-flight geo asset check before Xray initialization"
      contains: "geoasset.EnsureAssets"
    - path: "internal/lifecycle/cleanup.go"
      provides: "Platform-gated cleanup with runtime.GOOS checks"
      contains: "runtime.GOOS"
  key_links:
    - from: "internal/engine/engine.go"
      to: "internal/geoasset/geoasset.go"
      via: "Engine.Start calls EnsureAssets before core.New"
      pattern: "geoasset\\.EnsureAssets"
    - from: "internal/lifecycle/cleanup.go"
      to: "internal/sysproxy"
      via: "runtime.GOOS == darwin gate before sysproxy calls"
      pattern: 'runtime\.GOOS.*==.*"darwin"'
    - from: "internal/lifecycle/cleanup.go"
      to: "internal/killswitch"
      via: "runtime.GOOS == darwin gate before pfctl calls"
      pattern: 'runtime\.GOOS.*==.*"darwin"'
---

<objective>
Implement geo asset auto-download for first-run experience and add platform gating to recovery commands for Linux compatibility.

Purpose: Fresh installs auto-download required Xray routing data files (geoip.dat, geosite.dat) with integrity verification, and recovery commands (--cleanup, --reset-terminal) work correctly on both macOS and Linux without calling platform-specific binaries that don't exist.
Output: New `geoasset` package for download/verify, engine integration for pre-flight check, platform-gated cleanup code.
</objective>

<execution_context>
@/Users/lee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-distribution/06-RESEARCH.md
@internal/engine/engine.go
@internal/lifecycle/cleanup.go
@internal/config/paths.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create geoasset package with download, verify, and test</name>
  <files>internal/geoasset/geoasset.go, internal/geoasset/geoasset_test.go</files>
  <action>
Create `internal/geoasset/geoasset.go`:

**Constants:**
- `baseURL = "https://github.com/Loyalsoldier/v2ray-rules-dat/releases/latest/download/"` (uses /latest/download/ redirect so it always fetches current data)
- Define an `Asset` struct: `Name string, URL string, SHA256URL string`
- Package-level `Assets` slice with two entries:
  - `{Name: "geoip.dat", URL: baseURL + "geoip.dat", SHA256URL: baseURL + "geoip.dat.sha256sum"}`
  - `{Name: "geosite.dat", URL: baseURL + "geosite.dat", SHA256URL: baseURL + "geosite.dat.sha256sum"}`

**`EnsureAssets(dataDir string) error` function:**
1. For each asset in `Assets`, check if `filepath.Join(dataDir, asset.Name)` exists via `os.Stat`
2. If file exists, skip (continue)
3. If missing, print `fmt.Printf("Downloading %s...\n", asset.Name)` and call `downloadAndVerify(asset, path)`
4. Return error wrapping asset name on failure

**`downloadAndVerify(asset Asset, destPath string) error` function:**
1. Download the file to `destPath + ".tmp"` using `http.Get(asset.URL)`. Read response body and write to temp file. Check HTTP status is 200.
2. Download the SHA256 checksum file using `http.Get(asset.SHA256URL)`. Parse the first field (hex hash) from the response body (format: `<hash>  <filename>\n`). Use `strings.Fields` to split.
3. Compute SHA256 of the downloaded temp file: reopen, `io.Copy` to `sha256.New()`, `hex.EncodeToString`.
4. Compare computed hash with expected hash (case-insensitive via `strings.EqualFold`).
5. If mismatch, remove temp file and return error with both hashes.
6. Atomic rename: `os.Rename(tmpPath, destPath)`.
7. Print `fmt.Printf("Downloaded %s (verified)\n", asset.Name)`.

**Use `os.MkdirAll(filepath.Dir(destPath), 0700)` before writing** to ensure the data directory exists.

**Make `http.Client` a package-level var `httpClient = &http.Client{Timeout: 5 * time.Minute}`** for testability (tests can replace it) and to avoid hanging downloads.

Create `internal/geoasset/geoasset_test.go`:

**Test `TestEnsureAssets_DownloadsWhenMissing`:**
1. Start `httptest.NewServer` that serves fake geo file content at `/geoip.dat` and a valid SHA256 checksum at `/geoip.dat.sha256sum` (compute SHA256 of the fake content).
2. Override the package-level `Assets` slice to point at the test server URLs.
3. Call `EnsureAssets(tempDir)`.
4. Assert the file exists in tempDir and its content matches.

**Test `TestEnsureAssets_SkipsExisting`:**
1. Pre-create a file at `tempDir/geoip.dat`.
2. Call `EnsureAssets(tempDir)`.
3. Assert no HTTP requests were made (use a counter in test server handler).

**Test `TestEnsureAssets_FailsOnChecksumMismatch`:**
1. Serve file content but wrong checksum.
2. Assert `EnsureAssets` returns an error containing "checksum".
3. Assert no file remains at the destination (temp cleaned up).
  </action>
  <verify>
    <automated>cd /Users/lee/vless-terminal && go test ./internal/geoasset/ -v -count=1 2>&1 | tail -20</automated>
  </verify>
  <done>geoasset package downloads missing geo files with SHA256 verification, skips existing files, and fails cleanly on checksum mismatch. All three test cases pass.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate geo pre-flight into Engine.Start and platform-gate cleanup</name>
  <files>internal/engine/engine.go, internal/lifecycle/cleanup.go</files>
  <action>
**Engine.Start integration (`internal/engine/engine.go`):**

In `Engine.Start()`, right after the existing `config.DataDir()` call and `os.Setenv("XRAY_LOCATION_ASSET", dataDir)` line (around line 69-71), add a call to `geoasset.EnsureAssets(dataDir)`. This must happen BEFORE `core.New(coreConfig)` because Xray panics if geoip.dat is missing when routing rules reference `geoip:private`.

Add import: `"github.com/leejooy96/azad/internal/geoasset"`

The call should be:
```go
if err := geoasset.EnsureAssets(dataDir); err != nil {
    return fmt.Errorf("ensuring geo assets: %w", err)
}
```

Place this AFTER setting `XRAY_LOCATION_ASSET` env var and BEFORE `BuildConfig` / `core.New`.

**Platform-gate cleanup (`internal/lifecycle/cleanup.go`):**

Add import `"runtime"` to the imports.

Wrap the `sysproxy.UnsetSystemProxy` call inside `RunCleanup` with a `runtime.GOOS` check:
- If `runtime.GOOS == "darwin"`: call `sysproxy.UnsetSystemProxy(state.NetworkService)` as before
- If `runtime.GOOS == "linux"`: print `"Linux: proxy was application-level, no system proxy to clean up."` (SOCKS/HTTP proxy on Linux is app-level, not system-wide)

Wrap the `killswitch.Cleanup()` call with a `runtime.GOOS` check:
- If `runtime.GOOS == "darwin"`: call `killswitch.Cleanup()` as before
- If `runtime.GOOS == "linux"`: print `"Linux: kill switch cleanup not yet supported. Manual: sudo iptables -F azad"` (iptables is the Linux equivalent; full implementation deferred to v2)

This ensures the binary compiles and runs on Linux without calling networksetup or pfctl which don't exist.

NOTE: Do NOT remove the existing sysproxy or killswitch imports -- they are still used on macOS. The conditional logic ensures they are only called on darwin.
  </action>
  <verify>
    <automated>cd /Users/lee/vless-terminal && go build ./cmd/azad && grep -q "geoasset.EnsureAssets" internal/engine/engine.go && grep -q "runtime.GOOS" internal/lifecycle/cleanup.go && echo "PASS"</automated>
  </verify>
  <done>Engine.Start calls geoasset.EnsureAssets before Xray initialization. Cleanup code is platform-gated: macOS calls sysproxy/killswitch, Linux prints informational messages. Binary compiles successfully.</done>
</task>

</tasks>

<verification>
- `internal/geoasset/geoasset.go` exports `EnsureAssets(dataDir string) error`
- `internal/geoasset/geoasset_test.go` has tests for download, skip-existing, and checksum-mismatch
- All geoasset tests pass
- `internal/engine/engine.go` calls `geoasset.EnsureAssets` before `core.New`
- `internal/lifecycle/cleanup.go` uses `runtime.GOOS` to gate macOS-specific calls
- `go build ./cmd/azad` succeeds
</verification>

<success_criteria>
First-run experience auto-downloads geo assets with integrity verification. Recovery commands are platform-safe for both macOS and Linux. Existing macOS behavior is unchanged.
</success_criteria>

<output>
After completion, create `.planning/phases/06-distribution/06-02-SUMMARY.md`
</output>
