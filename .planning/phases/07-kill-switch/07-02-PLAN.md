---
phase: 07-kill-switch
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - internal/cli/connect.go
  - internal/cli/root.go
  - internal/tui/app.go
  - internal/tui/connect_cmd.go
  - internal/tui/keys.go
  - internal/tui/messages.go
  - internal/tui/statusbar.go
autonomous: true
requirements: [KILL-01, KILL-02, KILL-03, KILL-04, KILL-05]

must_haves:
  truths:
    - "User can toggle kill switch in TUI via K keybinding with confirmation"
    - "User can enable kill switch in headless mode via azad connect --kill-switch"
    - "After crash with kill switch active, running azad reconnects and restores internet"
    - "After crash with kill switch active, running azad --cleanup removes firewall rules"
    - "Terminal shows close-confirmation dialog when kill switch is active (automatic via foreground process)"
    - "Status bar shows kill switch state when active"
    - "Disconnecting with kill switch active disables the kill switch"
  artifacts:
    - path: "internal/cli/connect.go"
      provides: "--kill-switch flag for headless connect"
      contains: "kill-switch"
    - path: "internal/cli/root.go"
      provides: "Startup kill switch recovery detection"
      contains: "KillSwitchActive"
    - path: "internal/tui/app.go"
      provides: "K keybinding handler and kill switch confirmation overlay"
      contains: "viewConfirmKillSwitch"
    - path: "internal/tui/connect_cmd.go"
      provides: "enableKillSwitchCmd and disableKillSwitchCmd tea.Cmd functions"
      contains: "enableKillSwitchCmd"
    - path: "internal/tui/keys.go"
      provides: "KillSwitch keybinding"
      contains: "KillSwitch"
    - path: "internal/tui/messages.go"
      provides: "killSwitchResultMsg message type"
      contains: "killSwitchResultMsg"
    - path: "internal/tui/statusbar.go"
      provides: "Kill switch indicator in status bar"
      contains: "killSwitch"
  key_links:
    - from: "internal/tui/connect_cmd.go"
      to: "internal/killswitch/killswitch.go"
      via: "enableKillSwitchCmd calls killswitch.Enable"
      pattern: "killswitch\\.Enable"
    - from: "internal/cli/connect.go"
      to: "internal/killswitch/killswitch.go"
      via: "--kill-switch flag enables kill switch after connection"
      pattern: "killswitch\\.Enable"
    - from: "internal/cli/root.go"
      to: "internal/lifecycle/cleanup.go"
      via: "Startup reads ProxyState.KillSwitchActive for recovery"
      pattern: "KillSwitchActive"
    - from: "internal/tui/connect_cmd.go"
      to: "internal/tui/app.go"
      via: "killSwitchResultMsg updates model state"
      pattern: "killSwitchResultMsg"
---

<objective>
Wire the kill switch into CLI headless connect (--kill-switch flag), TUI toggle (K keybinding), startup recovery (reconnect after crash), and status display.

Purpose: Makes the kill switch user-accessible from both CLI and TUI, with proper crash recovery flow.
Output: Complete kill switch integration across CLI and TUI with recovery on startup.
</objective>

<execution_context>
@/Users/lee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-kill-switch/07-RESEARCH.md
@.planning/phases/07-kill-switch/07-01-SUMMARY.md
@.planning/phases/03-connection-engine/03-03-SUMMARY.md
@.planning/phases/05-quick-connect/05-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire kill switch into headless connect and startup recovery</name>
  <files>internal/cli/connect.go, internal/cli/root.go</files>
  <action>
**connect.go -- Add --kill-switch flag:**
1. Add a `killSwitchFlag bool` package-level var (following the existing `cleanup`/`resetTerminal` pattern).
2. In `newConnectCmd()`, add the flag: `cmd.Flags().BoolVar(&killSwitchFlag, "kill-switch", false, "Enable kill switch to block all non-VPN traffic")`.
3. In `runConnect()`, after the proxy is started and system proxy is set:
   a. If `killSwitchFlag` is true:
      - Resolve the server IP address. The server address might be a hostname -- use `net.LookupHost(server.Address)` to resolve it to an IP BEFORE enabling kill switch (per research pitfall 4: DNS leak). If resolution fails, use `server.Address` directly (it may already be an IP).
      - Call `killswitch.Enable(resolvedIP, server.Port)`. If it fails, print warning but do NOT abort the connection.
      - If it succeeds, print "Kill switch enabled -- all non-VPN traffic blocked."
   b. Update `writeProxyState` call to include kill switch fields:
      - Pass the additional KillSwitchActive, ServerAddress, ServerPort to the ProxyState struct before writing.
4. In the cleanup section (after `<-ctx.Done()`):
   a. If `killSwitchFlag` was active, call `killswitch.Disable()` before unsetting system proxy. Print "Kill switch disabled."
   b. Continue with existing engine stop and proxy unset flow.

**root.go -- Add startup recovery for kill switch:**
1. In `PersistentPreRunE`, BEFORE the `--cleanup` check, add kill switch recovery detection:
   a. Read the state file (similar pattern to RunCleanup): `config.StateFilePath()` -> `os.ReadFile` -> `json.Unmarshal` to `lifecycle.ProxyState`.
   b. If `state.KillSwitchActive == true` AND the command is NOT `--cleanup`:
      - Print: "Kill switch is active from a previous session. Internet is blocked."
      - Print: "Reconnecting to restore internet through VPN..."
      - Let the command proceed normally (if running `azad` -> TUI will auto-connect; if running `azad connect` -> will connect).
      - The key insight: the TUI auto-connect will re-establish the VPN, and the pf rules already allow traffic to the stored server. If the user runs `azad --cleanup`, the existing RunCleanup upgrade (from Plan 01) handles it.
   c. If `state.KillSwitchActive == true` AND command IS `--cleanup`:
      - Let the existing cleanup flow handle it (Plan 01 already upgraded RunCleanup).

Import `github.com/leejooy96/azad/internal/killswitch` and `net` in connect.go. Import `encoding/json` in root.go (if not already present).

Important: The `writeProxyState` function in connect.go needs to accept kill switch parameters. Extend its signature or create an inline ProxyState struct that includes the new fields. Keep it simple -- just add the fields directly when constructing the ProxyState in `runConnect`.
  </action>
  <verify>
    <automated>cd /Users/lee/vless-terminal && go build ./internal/cli/ && go vet ./internal/cli/</automated>
    <manual>Verify `azad connect --help` shows --kill-switch flag; verify root.go reads state file on startup</manual>
  </verify>
  <done>`azad connect --kill-switch` enables kill switch after proxy start; startup detects active kill switch and informs user; cleanup handles kill switch removal; server hostname resolved to IP before enabling kill switch</done>
</task>

<task type="auto">
  <name>Task 2: Wire kill switch toggle into TUI with status display</name>
  <files>internal/tui/keys.go, internal/tui/messages.go, internal/tui/connect_cmd.go, internal/tui/app.go, internal/tui/statusbar.go</files>
  <action>
**keys.go -- Add KillSwitch keybinding:**
Add `KillSwitch key.Binding` to the `keyMap` struct.
In `defaultKeyMap()`: `KillSwitch: key.NewBinding(key.WithKeys("K"), key.WithHelp("K", "kill switch"))`.
Add KillSwitch to the FullHelp() group with Delete/ClearAll/Quit/Help.

**messages.go -- Add kill switch message:**
Add `killSwitchResultMsg struct { Enabled bool; Err error }` for the result of enable/disable operations.

**connect_cmd.go -- Add kill switch tea.Cmd functions:**
1. `enableKillSwitchCmd(eng *engine.Engine, cfg *config.Config) tea.Cmd`:
   - Get the currently connected server from `eng.Status()`. If not connected, return `killSwitchResultMsg{Err: fmt.Errorf("not connected")}`.
   - Resolve server address to IP via `net.LookupHost` (same pattern as CLI). Use the server's Address and Port.
   - Call `killswitch.Enable(resolvedIP, serverPort)`.
   - If successful, write updated ProxyState with `KillSwitchActive: true`, `ServerAddress: resolvedIP`, `ServerPort: serverPort` (extend `tuiWriteProxyState` or write inline).
   - Return `killSwitchResultMsg{Enabled: true}`.
2. `disableKillSwitchCmd() tea.Cmd`:
   - Call `killswitch.Disable()`.
   - Write updated ProxyState with `KillSwitchActive: false` (or just omit it since omitempty handles it).
   - Return `killSwitchResultMsg{Enabled: false}`.

**app.go -- Add kill switch view state and key handler:**
1. Add `viewConfirmKillSwitch` to the `viewState` enum (after `viewConfirmDelete`).
2. Add `killSwitchActive bool` field to the `model` struct.
3. In `handleKeyPress`, in the `viewNormal` section, add case `"K"`:
   - If kill switch is currently active (`m.killSwitchActive`): disable it directly (no confirmation needed for disabling).
     Return `disableKillSwitchCmd()`.
   - If kill switch is NOT active: show confirmation overlay.
     Set `m.view = viewConfirmKillSwitch`. Return nil.
4. Add `viewConfirmKillSwitch` case in `handleKeyPress`:
   - `"y"` or `"enter"`: set `m.view = viewNormal`, return `enableKillSwitchCmd(m.engine, m.cfg)`.
   - `"n"` or `"esc"`: set `m.view = viewNormal`, return nil.
5. Add `killSwitchResultMsg` case in `Update`:
   - If `msg.Err != nil`: flash error (set on input.err or just log -- follow existing pattern).
   - If `msg.Enabled`: set `m.killSwitchActive = true`, update status bar.
   - If `!msg.Enabled`: set `m.killSwitchActive = false`, update status bar.
6. In the `View()` method, add `viewConfirmKillSwitch` overlay rendering (same pattern as `viewConfirmDelete`):
   - Render a centered box: "Enable kill switch?\n\nThis blocks ALL non-VPN traffic.\nRequires admin password.\n\n(y) Yes  (n) No"
   - Use Warning color for the border (same as confirm delete).
7. In the quit handler (`"q"`, `"ctrl+c"`), if `m.killSwitchActive`:
   - Add `disableKillSwitchCmd()` to the sequence: `tea.Sequence(disableKillSwitchCmd(), disconnectCmd(m.engine), tea.Quit)`.
8. In the disconnect handler, when disconnect completes (disconnectMsg case), if kill switch was active:
   - The disconnectCmd should also disable kill switch. Update `disconnectCmd` to check and disable kill switch if active. Add a `killSwitchActive bool` parameter to `disconnectCmd` and call `killswitch.Disable()` if true.
   - Alternatively: keep it simpler -- update the disconnect flow in the `"q"` key handler to sequence disable kill switch before disconnect. For the `"enter"/"c"` reconnect case, the kill switch stays active through the server switch.
9. On startup, check `killswitch.IsActive()` in `New()` and set `m.killSwitchActive` accordingly.

**statusbar.go -- Add kill switch indicator:**
Add a `killSwitch bool` field to `statusBarModel`.
Add a `SetKillSwitch(active bool)` method.
In `View()`, when `killSwitch` is true, prepend or append a kill switch indicator to the status bar. Use a bold/warning-colored label like `[KILL SWITCH]` or a lock icon equivalent text `KILL SW: ON`. Keep it concise for the status bar.
Call `m.statusBar.SetKillSwitch(true/false)` from the killSwitchResultMsg handler in app.go.

Import `github.com/leejooy96/azad/internal/killswitch` and `net` in connect_cmd.go.
  </action>
  <verify>
    <automated>cd /Users/lee/vless-terminal && go build ./... && go vet ./internal/tui/</automated>
    <manual>Review that K keybinding shows in help, status bar shows kill switch state, quit disables kill switch, confirmation overlay appears before enabling</manual>
  </verify>
  <done>TUI K keybinding toggles kill switch with confirmation dialog; status bar shows kill switch state; quit/disconnect disables kill switch; auto-connect on startup works with existing kill switch pf rules; killswitch.IsActive() checked on TUI init for recovery state</done>
</task>

</tasks>

<verification>
1. `go build ./...` passes (entire project compiles with kill switch integration)
2. `go vet ./...` passes
3. `azad connect --help` shows `--kill-switch` flag
4. TUI help overlay shows K keybinding for kill switch
5. Status bar has kill switch indicator field
6. Quit sequence includes kill switch disable when active
7. Startup reads state file and detects active kill switch for recovery messaging
</verification>

<success_criteria>
- `azad connect --kill-switch` enables kill switch after proxy connection with server IP resolution
- TUI K keybinding shows confirmation, then calls killswitch.Enable on confirm
- TUI K when active calls killswitch.Disable without confirmation
- Status bar shows kill switch active state
- Quitting TUI while kill switch active disables kill switch then disconnects
- Startup recovery detects active kill switch and informs user
- `azad --cleanup` removes kill switch rules (via Plan 01 RunCleanup upgrade)
- Terminal close confirmation is automatic (macOS detects foreground process -- KILL-05)
</success_criteria>

<output>
After completion, create `.planning/phases/07-kill-switch/07-02-SUMMARY.md`
</output>
