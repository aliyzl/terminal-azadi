---
phase: 03-connection-engine
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - internal/engine/config.go
  - internal/engine/config_test.go
autonomous: true
requirements:
  - CONN-01

must_haves:
  truths:
    - "BuildConfig produces valid Xray JSON with SOCKS5 and HTTP inbounds on configurable ports"
    - "VLESS outbound includes vnext with UUID, encryption, flow, and correct streamSettings"
    - "VMess outbound includes vnext with UUID, alterId, security, and correct streamSettings"
    - "Trojan outbound includes servers with password and correct streamSettings"
    - "Shadowsocks outbound includes servers with method, password, and no streamSettings when plain"
    - "StreamSettings correctly maps network types (tcp, ws, grpc, httpupgrade) with their sub-settings"
    - "TLS, REALITY, and no-TLS security modes produce correct security and settings blocks"
  artifacts:
    - path: "internal/engine/config.go"
      provides: "Xray JSON config builder from protocol.Server"
      exports: ["BuildConfig"]
    - path: "internal/engine/config_test.go"
      provides: "Table-driven tests for all 4 protocols and transport/security combinations"
      min_lines: 100
  key_links:
    - from: "internal/engine/config.go"
      to: "internal/protocol/server.go"
      via: "import protocol.Server, protocol.Protocol* constants"
      pattern: "protocol\\.Server"
    - from: "internal/engine/config.go"
      to: "github.com/xtls/xray-core/infra/conf/serial"
      via: "serial.LoadJSONConfig for JSON->protobuf conversion"
      pattern: "serial\\.LoadJSONConfig"
---

<objective>
Build the Xray JSON config generator that converts a protocol.Server struct into a valid *core.Config for all four protocols (VLESS, VMess, Trojan, Shadowsocks) with correct transport and security settings.

Purpose: This is the bridge between parsed server data (Phase 2) and the Xray proxy engine. Every connection starts with config generation -- if the JSON is wrong, nothing works.
Output: internal/engine/config.go with BuildConfig function, internal/engine/config_test.go with comprehensive tests.
</objective>

<execution_context>
@/Users/lee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-connection-engine/03-RESEARCH.md
@internal/protocol/server.go
@internal/config/config.go
@cmd/azad/main.go
</context>

<feature>
  <name>Xray JSON Config Builder</name>
  <files>internal/engine/config.go, internal/engine/config_test.go</files>
  <behavior>
    BuildConfig(srv protocol.Server, socksPort int, httpPort int) (*core.Config, error)

    Converts a protocol.Server into a complete Xray JSON config and loads it via serial.LoadJSONConfig.

    The JSON config structure:
    - log: { loglevel: "warning" }
    - inbounds: SOCKS5 on 127.0.0.1:socksPort (udp:true) + HTTP on 127.0.0.1:httpPort
    - outbounds: protocol-specific proxy outbound + "freedom" direct outbound
    - routing: route geoip:private to direct, everything else to proxy

    Protocol outbound mappings:
    - VLESS: protocol "vless", settings.vnext[0] with address/port/users[0] (id=UUID, encryption=Encryption or "none", flow=Flow)
    - VMess: protocol "vmess", settings.vnext[0] with address/port/users[0] (id=UUID, alterId=AlterID, security=Security or "auto")
    - Trojan: protocol "trojan", settings.servers[0] with address/port/password=Password
    - Shadowsocks: protocol "shadowsocks", settings.servers[0] with address/port/method=Method/password=Password

    Stream settings mapping (all protocols except plain SS):
    - network: srv.Network (default "tcp")
    - security: srv.TLS ("tls" -> tlsSettings, "reality" -> realitySettings, "" or "none" -> omit)
    - wsSettings: { path: srv.Path, headers: { Host: srv.Host } } when network="ws"
    - grpcSettings: { serviceName: srv.ServiceName } when network="grpc"
    - httpupgradeSettings: { path: srv.Path, host: srv.Host } when network="httpupgrade"
    - tlsSettings: { serverName: srv.SNI, fingerprint: srv.Fingerprint, alpn: split(srv.ALPN, ","), allowInsecure: srv.AllowInsecure }
    - realitySettings: { serverName: srv.SNI, fingerprint: srv.Fingerprint or "chrome", publicKey: srv.PublicKey, shortId: srv.ShortID, spiderX: srv.SpiderX }

    Test cases (input -> expected JSON structure):
    - VLESS + REALITY + tcp -> vnext with flow, realitySettings with publicKey/shortId
    - VLESS + TLS + ws -> vnext without flow, wsSettings with path, tlsSettings
    - VMess + TLS + ws -> vnext with alterId/security, wsSettings, tlsSettings
    - VMess + none + tcp -> vnext, no security block
    - Trojan + TLS + tcp -> servers with password, tlsSettings with serverName
    - Trojan + TLS + grpc -> servers, grpcSettings with serviceName, tlsSettings
    - Shadowsocks plain -> servers with method/password, no streamSettings
    - Port configuration -> SOCKS5 and HTTP inbounds use provided ports
    - Invalid/unsupported protocol -> returns error
    - Routing config -> geoip:private routes to direct tag

    Tests verify JSON structure (marshal XrayConfig, check fields) AND that serial.LoadJSONConfig accepts the output without error.
  </behavior>
  <implementation>
    Define Go structs matching Xray JSON format: XrayConfig, LogConfig, InboundConfig, OutboundConfig, RoutingConfig, StreamSettings, TLSSettings, RealitySettings, WsSettings, GrpcSettings, HttpUpgradeSettings.

    Use json.RawMessage for outbound settings (different structure per protocol).

    BuildConfig function:
    1. Construct inbounds (SOCKS5 + HTTP) with provided ports
    2. Switch on srv.Protocol to build protocol-specific outbound
    3. Build streamSettings based on srv.Network + srv.TLS
    4. Add freedom outbound + routing rules
    5. Marshal to JSON bytes
    6. Call serial.LoadJSONConfig(bytes.NewReader(jsonBytes)) to validate and convert

    Set XRAY_LOCATION_ASSET env var before LoadJSONConfig if geoip.dat/geosite.dat are needed for routing rules. For tests, use a routing config that doesn't reference geo files, OR set the env var to the project root where these files exist.

    IMPORTANT: The blank import `_ "github.com/xtls/xray-core/main/distro/all"` is already in cmd/azad/main.go. For tests, add this same blank import in config_test.go to register JSON config loader and protocol handlers.

    Use json.RawMessage for protocol-specific settings fields to keep the builder clean. Each buildXxxOutbound helper returns the settings as json.RawMessage.
  </implementation>
</feature>

<verification>
go test ./internal/engine/ -v -count=1
All tests pass. serial.LoadJSONConfig succeeds for all 4 protocol configs.
</verification>

<success_criteria>
- BuildConfig produces valid *core.Config for VLESS, VMess, Trojan, and Shadowsocks servers
- SOCKS5 and HTTP inbound ports are configurable
- Transport settings (ws, grpc, httpupgrade, tcp) correctly mapped
- Security settings (tls, reality, none) correctly mapped with appropriate sub-settings
- serial.LoadJSONConfig accepts all generated configs without error
- Tests cover all 4 protocols with at least 2 transport/security variations
- Unsupported protocol returns meaningful error
</success_criteria>

<output>
After completion, create `.planning/phases/03-connection-engine/03-01-SUMMARY.md`
</output>
