---
phase: 03-connection-engine
plan: 03
type: execute
wave: 2
depends_on:
  - "03-01"
  - "03-02"
files_modified:
  - internal/engine/engine.go
  - internal/engine/verify.go
  - internal/cli/connect.go
autonomous: true
requirements:
  - CONN-01
  - CONN-02
  - CONN-03
  - CONN-04

must_haves:
  truths:
    - "Engine.Start creates Xray instance from protocol.Server and starts proxy on configured ports"
    - "Engine.Stop calls instance.Close, nils the reference, and transitions to Disconnected"
    - "ConnectionStatus transitions follow: Disconnected->Connecting->Connected or Disconnected->Connecting->Error"
    - "VerifyIP fetches external IP through the SOCKS5 proxy and returns it"
    - "azad connect <server> loads server store, finds server, starts engine, sets proxy, verifies IP, and prints status"
    - "azad connect handles graceful shutdown via context cancellation (SIGINT/SIGTERM stops proxy and unsets system proxy)"
  artifacts:
    - path: "internal/engine/engine.go"
      provides: "Engine struct with Start/Stop and ConnectionStatus state machine"
      exports: ["Engine", "ConnectionStatus", "StatusDisconnected", "StatusConnecting", "StatusConnected", "StatusError"]
    - path: "internal/engine/verify.go"
      provides: "IP verification through SOCKS5 proxy"
      exports: ["VerifyIP"]
    - path: "internal/cli/connect.go"
      provides: "Wired connect command using engine, sysproxy, and verify"
      min_lines: 40
  key_links:
    - from: "internal/engine/engine.go"
      to: "internal/engine/config.go"
      via: "Calls BuildConfig to get *core.Config"
      pattern: "BuildConfig"
    - from: "internal/engine/engine.go"
      to: "github.com/xtls/xray-core/core"
      via: "core.New + instance.Start / instance.Close"
      pattern: "core\\.New|instance\\.Start|instance\\.Close"
    - from: "internal/engine/verify.go"
      to: "golang.org/x/net/proxy"
      via: "SOCKS5 proxy dialer for HTTP client"
      pattern: "proxy\\.SOCKS5"
    - from: "internal/cli/connect.go"
      to: "internal/engine/engine.go"
      via: "Creates Engine, calls Start/Stop"
      pattern: "engine\\.Engine|engine\\.Start|engine\\.Stop"
    - from: "internal/cli/connect.go"
      to: "internal/sysproxy"
      via: "Calls DetectNetworkService, SetSystemProxy, UnsetSystemProxy"
      pattern: "sysproxy\\."
    - from: "internal/cli/connect.go"
      to: "internal/engine/verify.go"
      via: "Calls VerifyIP after connecting"
      pattern: "engine\\.VerifyIP|verify\\.VerifyIP"
    - from: "internal/cli/connect.go"
      to: "internal/lifecycle/cleanup.go"
      via: "Writes ProxyState to .state.json before setting system proxy"
      pattern: "lifecycle\\.ProxyState|StateFilePath"
---

<objective>
Implement the Xray proxy engine lifecycle (Start/Stop with state machine), IP verification through the proxy, and wire the `azad connect` command to orchestrate the full connection flow: find server -> start engine -> set proxy -> verify IP -> wait for shutdown -> stop engine -> unset proxy.

Purpose: This is where everything comes together -- the connect command is the user-facing entry point that exercises the entire Phase 3 stack.
Output: internal/engine/engine.go, internal/engine/verify.go, internal/cli/connect.go (rewritten from stub).
</objective>

<execution_context>
@/Users/lee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-connection-engine/03-RESEARCH.md
@.planning/phases/03-connection-engine/03-01-SUMMARY.md
@.planning/phases/03-connection-engine/03-02-SUMMARY.md
@internal/engine/config.go
@internal/sysproxy/sysproxy.go
@internal/sysproxy/detect.go
@internal/protocol/server.go
@internal/config/config.go
@internal/config/paths.go
@internal/lifecycle/cleanup.go
@internal/lifecycle/signals.go
@internal/serverstore/store.go
@cmd/azad/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement engine lifecycle with state machine</name>
  <files>internal/engine/engine.go</files>
  <action>
    Create internal/engine/engine.go with the Engine struct that manages Xray-core proxy lifecycle.

    **ConnectionStatus type:**
    ```go
    type ConnectionStatus int
    const (
        StatusDisconnected ConnectionStatus = iota
        StatusConnecting
        StatusConnected
        StatusError
    )
    func (s ConnectionStatus) String() string // Returns "disconnected", "connecting", "connected", "error"
    ```

    **Engine struct:**
    ```go
    type Engine struct {
        mu       sync.Mutex
        instance *core.Instance
        status   ConnectionStatus
        server   *protocol.Server
        err      error
    }
    ```

    **Engine.Start(ctx context.Context, srv protocol.Server, socksPort, httpPort int) error:**
    1. Lock mutex
    2. If already connected (instance != nil), return error "already connected"
    3. Set status to StatusConnecting
    4. Set XRAY_LOCATION_ASSET env var to DataDir() path (for geoip.dat/geosite.dat routing)
    5. Call BuildConfig(srv, socksPort, httpPort) to get *core.Config
    6. Call core.New(config) to create instance
    7. Call instance.Start() to begin proxy
    8. If any step fails: set status to StatusError, store error, close instance if created, unlock and return error
    9. On success: store instance and server, set status to StatusConnected
    10. Unlock and return nil

    **Engine.Stop() error:**
    1. Lock mutex
    2. If instance is nil, set status to Disconnected, unlock and return nil
    3. Call instance.Close()
    4. Set instance = nil, server = nil
    5. Set status to StatusDisconnected
    6. Unlock and return close error (if any)

    **Engine.Status() (ConnectionStatus, *protocol.Server, error):**
    - Lock, read status/server/err, unlock, return

    **Engine.ServerName() string:**
    - Returns server.Name if connected, empty string otherwise

    Note: Do NOT forget to nil the instance reference after Close() -- a closed instance cannot be restarted (per RESEARCH Pitfall 5). Always create a new instance for each connection.

    Import `"github.com/xtls/xray-core/core"` for core.New and core.Instance.
    Import `"github.com/leejooy96/azad/internal/protocol"` for protocol.Server.
  </action>
  <verify>
    <automated>cd /Users/lee/vless-terminal && go build ./internal/engine/</automated>
    <manual>Verify engine.go exports Engine, ConnectionStatus, Start, Stop, Status</manual>
  </verify>
  <done>Engine struct with Start/Stop lifecycle and ConnectionStatus state machine compiles. Start creates xray instance. Stop closes and nils it. Status is thread-safe.</done>
</task>

<task type="auto">
  <name>Task 2: Implement IP verification through proxy</name>
  <files>internal/engine/verify.go</files>
  <action>
    Create internal/engine/verify.go with VerifyIP function.

    **VerifyIP(socksPort int) (proxyIP string, err error):**
    1. Create SOCKS5 dialer: `proxy.SOCKS5("tcp", fmt.Sprintf("127.0.0.1:%d", socksPort), nil, proxy.Direct)`
    2. Create HTTP transport with the SOCKS5 dialer: `&http.Transport{Dial: dialer.Dial}`
    3. Create HTTP client with transport and 10-second timeout
    4. GET "https://icanhazip.com" through the proxy
    5. Read response body, trim whitespace
    6. Return the IP string
    7. Wrap all errors with fmt.Errorf context

    **GetDirectIP() (string, error):**
    1. Standard HTTP GET to "https://icanhazip.com" with 10-second timeout (no proxy)
    2. Return trimmed IP string
    3. This is used by the connect command to compare proxy IP vs direct IP

    Import `"golang.org/x/net/proxy"` for SOCKS5 dialer. This is already an indirect dependency via xray-core. Run `go get golang.org/x/net/proxy` if needed to make it direct.

    Note: Use `Dial` not `DialContext` on the SOCKS5 dialer -- the proxy.Dialer interface returns a Dial function, not DialContext. The http.Transport.Dial field accepts this directly.
  </action>
  <verify>
    <automated>cd /Users/lee/vless-terminal && go build ./internal/engine/</automated>
    <manual>Verify verify.go exports VerifyIP and GetDirectIP</manual>
  </verify>
  <done>VerifyIP fetches external IP through SOCKS5 proxy. GetDirectIP fetches IP directly. Both compile cleanly.</done>
</task>

<task type="auto">
  <name>Task 3: Wire connect command with full connection flow</name>
  <files>internal/cli/connect.go</files>
  <action>
    Rewrite internal/cli/connect.go (currently a stub printing "not yet implemented") to orchestrate the full connection flow.

    **newConnectCmd() returns a cobra.Command with:**
    - Use: "connect [server-name]"
    - Short: "Connect to a VPN server"
    - Args: cobra.MaximumNArgs(1) -- optional server name/ID
    - RunE: the connection orchestrator function

    **Connection flow in RunE:**
    1. Load config: `cfg, err := config.Load(configFilePath)`
    2. Load server store: `store, err := serverstore.New(serversFilePath)`
    3. Find server to connect to:
       - If args[0] provided: search store by name (case-insensitive contains match) or by ID
       - If no args: use config.Server.LastUsed if set, otherwise first server in store
       - If no servers found: print error "no servers available. Add one with: azad servers add <uri>"
    4. Print "Connecting to %s (%s:%d)..." with server name, address, port
    5. Start engine: `eng := &engine.Engine{}; err = eng.Start(ctx, server, cfg.Proxy.SOCKSPort, cfg.Proxy.HTTPPort)`
    6. On engine start failure: print error and return
    7. Print "Proxy started on SOCKS5://127.0.0.1:%d and HTTP://127.0.0.1:%d"
    8. Detect network service: `svc, err := sysproxy.DetectNetworkService()`
    9. Write ProxyState to .state.json BEFORE setting proxy (crash safety):
       ```go
       state := lifecycle.ProxyState{
           ProxySet: true, SOCKSPort: cfg.Proxy.SOCKSPort,
           HTTPPort: cfg.Proxy.HTTPPort, NetworkService: svc, PID: os.Getpid(),
       }
       ```
       Write JSON to StateFilePath
    10. Set system proxy: `sysproxy.SetSystemProxy(svc, cfg.Proxy.SOCKSPort, cfg.Proxy.HTTPPort)`
    11. If proxy set fails: print warning but continue (user can use SOCKS5 manually)
    12. Verify connection: `proxyIP, err := engine.VerifyIP(cfg.Proxy.SOCKSPort)`
    13. If verify succeeds: print "Connected! Your IP: %s" with the proxy IP
    14. If verify fails: print warning "Could not verify connection: %v" but stay connected
    15. Print status: "Status: %s | Server: %s | Press Ctrl+C to disconnect"
    16. Wait for context cancellation: `<-ctx.Done()`
    17. Print "Disconnecting..."
    18. Stop engine: `eng.Stop()`
    19. Unset system proxy: `sysproxy.UnsetSystemProxy(svc)`
    20. Remove .state.json
    21. Print "Disconnected."

    **File path helpers:** Use config.Dir() for store path, config.StateFilePath() for state file, config.FilePath() for config file. Server store path is filepath.Join(dataDir, "servers.json").

    **Graceful shutdown:** The ctx comes from cmd.Context() which is the signal-aware context from main.go. When SIGINT/SIGTERM fires, ctx.Done() closes and the cleanup sequence runs.

    **Error handling philosophy:** Connection errors are fatal (return error). System proxy and verify errors are warnings (print but continue). This ensures the user always has a working SOCKS5/HTTP proxy even if system proxy or IP check fails.

    Imports needed:
    - "github.com/leejooy96/azad/internal/config"
    - "github.com/leejooy96/azad/internal/engine"
    - "github.com/leejooy96/azad/internal/lifecycle"
    - "github.com/leejooy96/azad/internal/protocol"
    - "github.com/leejooy96/azad/internal/serverstore"
    - "github.com/leejooy96/azad/internal/sysproxy"
  </action>
  <verify>
    <automated>cd /Users/lee/vless-terminal && go build ./...</automated>
    <manual>Run `go vet ./...` to verify no issues. Check that connect.go imports engine, sysproxy, serverstore, config, lifecycle packages.</manual>
  </verify>
  <done>azad connect command orchestrates full flow: load config -> find server -> start engine -> set proxy -> verify IP -> wait for signal -> stop engine -> unset proxy -> cleanup state. Build succeeds with all imports resolved.</done>
</task>

</tasks>

<verification>
go build ./... succeeds
go vet ./... passes
go test ./internal/engine/ -v passes (config builder tests from Plan 01)
The connect command compiles and wires all Phase 3 components together.
</verification>

<success_criteria>
- Engine.Start creates Xray instance and starts proxy on configured ports
- Engine.Stop closes instance cleanly, nils reference, transitions to Disconnected
- ConnectionStatus enum with String() method for display
- VerifyIP fetches external IP through SOCKS5 proxy
- GetDirectIP fetches IP without proxy for comparison
- azad connect finds server by name or uses last-used/first available
- Connect flow: start engine -> write state -> set proxy -> verify IP -> wait -> cleanup
- Graceful shutdown on SIGINT/SIGTERM: stop engine, unset proxy, remove state file
- All components compile and build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/03-connection-engine/03-03-SUMMARY.md`
</output>
