---
phase: 04-tui-and-server-interaction
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - internal/tui/input.go
  - internal/tui/ping.go
  - internal/tui/app.go
autonomous: false
requirements: [SRVR-02, SRVR-03, SRVR-04, SRVR-05, SRVR-06]

must_haves:
  truths:
    - "User can add a server by pressing a, pasting a URI, and pressing Enter"
    - "User can add servers from a subscription by pressing s, entering URL, and pressing Enter"
    - "User can refresh subscriptions by pressing r"
    - "User can remove a server with d and clear all with D (with confirmation)"
    - "Pinging all servers with p runs concurrently with visual progress and sorts list by latency"
  artifacts:
    - path: "internal/tui/input.go"
      provides: "Text input modal for add server URI and add subscription URL"
      contains: "inputModel"
    - path: "internal/tui/ping.go"
      provides: "Concurrent ping command and progress tracking"
      contains: "pingAllCmd"
    - path: "internal/tui/app.go"
      provides: "Updated root model with server management keybindings and input modal routing"
      contains: "viewAddServer"
  key_links:
    - from: "internal/tui/input.go"
      to: "internal/protocol/parse.go"
      via: "ParseURI called on submitted server URI"
      pattern: "protocol\\.ParseURI"
    - from: "internal/tui/input.go"
      to: "internal/subscription/subscription.go"
      via: "Fetch called for subscription URL"
      pattern: "subscription\\.Fetch"
    - from: "internal/tui/ping.go"
      to: "internal/serverstore/store.go"
      via: "Store updated with latency results"
      pattern: "store\\."
    - from: "internal/tui/app.go"
      to: "internal/tui/input.go"
      via: "Root model delegates to input modal in overlay views"
      pattern: "m\\.input"
---

<objective>
Add server management actions to the TUI: add server via URI, add subscription, refresh subscriptions, remove/clear servers, and concurrent ping-all with progress visualization and latency sorting.

Purpose: This completes the server interaction requirements, making the TUI a fully functional server management interface beyond just browsing.

Output: Users can manage their full server lifecycle through the TUI keyboard interface.
</objective>

<execution_context>
@/Users/lee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-tui-and-server-interaction/04-RESEARCH.md
@.planning/phases/04-tui-and-server-interaction/04-01-SUMMARY.md
@.planning/phases/04-tui-and-server-interaction/04-02-SUMMARY.md

@internal/tui/app.go
@internal/tui/messages.go
@internal/tui/serverlist.go
@internal/tui/keys.go
@internal/protocol/parse.go
@internal/protocol/server.go
@internal/subscription/subscription.go
@internal/serverstore/store.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create input modals for add server and subscription</name>
  <files>internal/tui/input.go</files>
  <action>
Create `internal/tui/input.go`:

Define input mode enum:
```go
type inputMode int
const (
    inputAddServer inputMode = iota
    inputAddSubscription
)
```

Define `inputModel` struct:
- Fields: `textInput textinput.Model`, `mode inputMode`, `err error`, `width int`

Create `newInputModel() inputModel`:
- Initialize `textinput.New()`
- Set placeholder: "Paste server URI (vless://, vmess://, trojan://, ss://)"
- Set character limit: 2048 (URIs can be long)
- Set width based on available space

Implement `SetMode(mode inputMode)`:
- Switch placeholder text based on mode:
  - `inputAddServer`: "Paste server URI (vless://, vmess://, trojan://, ss://)"
  - `inputAddSubscription`: "Paste subscription URL (https://...)"
- Clear current input value and error
- Focus the text input

Implement `Update(msg tea.Msg) (inputModel, tea.Cmd)`:
- Handle `tea.KeyPressMsg`:
  - `enter`: Submit current value — return appropriate command:
    - For addServer mode: return a `tea.Cmd` that calls `protocol.ParseURI(value)` and returns `serverAddedMsg` or `errMsg`
    - For addSubscription mode: return a `tea.Cmd` that calls `subscription.Fetch(value)` and returns `subscriptionFetchedMsg` or `errMsg`
  - `esc`: Return a special message to signal cancellation (the root model handles this by switching back to viewNormal)
  - Default: delegate to `m.textInput.Update(msg)` for character input, cursor movement, etc.

Implement `View() string`:
- Render a modal box:
  - Title: "Add Server" or "Add Subscription" based on mode
  - Text input field
  - Error message if m.err is set (in Error style)
  - Hint text: "Enter to submit, Esc to cancel"
- Style with border, padding, centered within available width

Define command functions (these run as tea.Cmd, returning messages):

```go
func addServerCmd(uri string, store *serverstore.Store) tea.Cmd {
    return func() tea.Msg {
        srv, err := protocol.ParseURI(uri)
        if err != nil {
            return errMsg{Err: fmt.Errorf("invalid URI: %w", err)}
        }
        if err := store.Add(srv); err != nil {
            return errMsg{Err: fmt.Errorf("adding server: %w", err)}
        }
        return serverAddedMsg{Server: srv}
    }
}

func addSubscriptionCmd(url string, store *serverstore.Store) tea.Cmd {
    return func() tea.Msg {
        servers, err := subscription.Fetch(url)
        if err != nil {
            return subscriptionFetchedMsg{Err: err}
        }
        if err := store.ReplaceBySource(url, servers); err != nil {
            return subscriptionFetchedMsg{Err: fmt.Errorf("storing servers: %w", err)}
        }
        return subscriptionFetchedMsg{Servers: servers}
    }
}

func refreshSubscriptionsCmd(store *serverstore.Store) tea.Cmd {
    return func() tea.Msg {
        // Get unique subscription sources from current servers
        servers := store.List()
        sources := make(map[string]bool)
        for _, srv := range servers {
            if srv.SubscriptionSource != "" {
                sources[srv.SubscriptionSource] = true
            }
        }
        if len(sources) == 0 {
            return errMsg{Err: fmt.Errorf("no subscriptions to refresh")}
        }
        total := 0
        for source := range sources {
            fetched, err := subscription.Fetch(source)
            if err != nil {
                continue // skip failed sources
            }
            _ = store.ReplaceBySource(source, fetched)
            total += len(fetched)
        }
        return serversReplacedMsg{Count: total}
    }
}
```

Import `charm.land/bubbles/v2/textinput` for the text input component, `protocol` for ParseURI, `subscription` for Fetch.

NOTE: The command functions take `store` as a parameter (NOT closing over model state). This is critical — commands run in goroutines and must not access model fields.
  </action>
  <verify>
    <automated>cd /Users/lee/vless-terminal && go build ./internal/tui/...</automated>
    <manual>Verify inputModel has SetMode, Update, View. Verify addServerCmd, addSubscriptionCmd, refreshSubscriptionsCmd are defined.</manual>
  </verify>
  <done>Input modal handles add-server and add-subscription modes with text input, enter/esc handling, and async command functions that call protocol.ParseURI and subscription.Fetch safely.</done>
</task>

<task type="auto">
  <name>Task 2: Create ping command, server management keybindings, and wire into root model</name>
  <files>internal/tui/ping.go, internal/tui/app.go</files>
  <action>
Create `internal/tui/ping.go`:

Define `pingAllCmd(servers []protocol.Server) tea.Cmd`:
- Build a slice of `tea.Cmd`, one per server
- Each command: `net.DialTimeout("tcp", fmt.Sprintf("%s:%d", srv.Address, srv.Port), 5*time.Second)`
- On success: return `pingResultMsg{ServerID: srv.ID, LatencyMs: int(time.Since(start).Milliseconds())}`
- On error: return `pingResultMsg{ServerID: srv.ID, Err: err}`
- Return `tea.Batch(cmds...)` to run all concurrently
- NOTE: Capture `srv` in loop via `srv := srv` to avoid closure bug

Define ping progress tracking fields (to be added to root model):
- `pinging bool` — whether ping batch is in progress
- `pingTotal int` — total servers being pinged
- `pingDone int` — servers completed so far

Update `internal/tui/app.go` to integrate server management:

Add fields to model struct:
- `input inputModel` — the input modal
- `pinging bool`, `pingTotal int`, `pingDone int` — ping progress
- `confirmDelete bool` — confirmation state for clear-all

In Update, add keybinding handlers for viewNormal:
- `a` (AddServer): Set `m.view = viewAddServer`, call `m.input.SetMode(inputAddServer)`, return `m.input.textInput.Focus()`
- `s` (AddSub): Set `m.view = viewAddSubscription`, call `m.input.SetMode(inputAddSubscription)`, return `m.input.textInput.Focus()`
- `r` (RefreshSub): Return `refreshSubscriptionsCmd(m.store)`
- `d` (Delete): Get selected server, call `m.store.Remove(id)`, return `serverRemovedMsg` or wrap in command
- `D` (ClearAll): Set `m.view = viewConfirmDelete` to ask confirmation
- `p` (PingAll): If not already pinging, set `m.pinging = true`, get servers from list, set `m.pingTotal = len(servers)`, `m.pingDone = 0`, return `pingAllCmd(servers)`

Handle viewConfirmDelete:
- `y` or `enter`: Call `m.store.Clear()` in a command, set `m.view = viewNormal`
- `n` or `esc`: Set `m.view = viewNormal`

Handle viewAddServer / viewAddSubscription:
- Delegate to `m.input.Update(msg)`
- On `esc` KeyPressMsg: Set `m.view = viewNormal`
- On `enter` KeyPressMsg: Submit via command (addServerCmd or addSubscriptionCmd)

Handle new message types in Update:
- `serverAddedMsg`: Reload servers from store into list items, set `m.view = viewNormal`
- `serverRemovedMsg`: Reload servers from store into list items
- `subscriptionFetchedMsg`: If err, show error. Else reload servers into list, set `m.view = viewNormal`
- `serversReplacedMsg`: Reload servers from store into list
- `pingResultMsg`: Increment `m.pingDone`. Find server in store, update its LatencyMs field via the store. If all done (pingDone == pingTotal), sort servers by latency, rebuild list items, set `m.pinging = false`.
- `errMsg`: Store error for display (could show in status bar briefly)

Helper method `reloadServers()` on model:
- Call `m.store.List()`, convert to items via `serversToItems()`, call `m.serverList.SetItems(items)`
- Preserve selected index if possible

In View, handle overlay states:
- `viewAddServer`, `viewAddSubscription`: Render input modal centered over content using `lipgloss.Place`
- `viewConfirmDelete`: Render a small confirmation dialog: "Clear all servers? (y/n)"

When `m.pinging`, show progress in the status bar or list title:
- Option: set list title to `fmt.Sprintf("Servers (pinging %d/%d...)", m.pingDone, m.pingTotal)` during ping
- Reset title to "Servers" when done

For delete single server (d key), wrap in a tea.Cmd to avoid blocking:
```go
func removeServerCmd(store *serverstore.Store, id string) tea.Cmd {
    return func() tea.Msg {
        if err := store.Remove(id); err != nil {
            return errMsg{Err: err}
        }
        return serverRemovedMsg{ServerID: id}
    }
}
```

For clear all:
```go
func clearAllCmd(store *serverstore.Store) tea.Cmd {
    return func() tea.Msg {
        if err := store.Clear(); err != nil {
            return errMsg{Err: err}
        }
        return serversReplacedMsg{Count: 0}
    }
}
```

NOTE: For updating server latency after ping, define a method or command:
```go
func updateLatencyCmd(store *serverstore.Store, serverID string, latencyMs int) tea.Cmd {
    return func() tea.Msg {
        // The store doesn't have an UpdateLatency method.
        // Workaround: load all servers, find by ID, update latency, save.
        // Alternatively, add a SetLatency(id, ms) method to store.
        // For now, track latencies in a map on the model and sort in-memory.
        return nil
    }
}
```

Since `serverstore.Store` doesn't have a `SetLatency` method, track ping results in a `map[string]int` on the model during pinging. When all pings complete:
1. Update the store's server entries if needed (or just sort the display list)
2. Rebuild `serverItem` list sorted by latency (ascending, errors last)
3. Set new items on the list model

This approach avoids modifying the serverstore package in this plan.
  </action>
  <verify>
    <automated>cd /Users/lee/vless-terminal && go build ./... && go test ./...</automated>
    <manual>Verify that a/s/r/d/D/p keybindings are handled in Update. Verify pingAllCmd uses tea.Batch. Verify input modal renders in overlay.</manual>
  </verify>
  <done>All server management keybindings wired: a=add server, s=add subscription, r=refresh, d=delete, D=clear all, p=ping all. Input modals overlay correctly. Ping runs concurrently and sorts results by latency. Existing tests pass.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify TUI works end-to-end</name>
  <files>none (verification only)</files>
  <action>
Human verifies the complete TUI:
- What was built: Full TUI with split-pane layout, keyboard navigation, server management (add/remove/ping), help overlay, and adaptive layout
- How to verify:
  1. Run `go run ./cmd/azad/` — TUI should launch in alt-screen mode with split-pane layout
  2. Press `?` — help overlay should appear with all keybindings
  3. Press `esc` or `?` — help should dismiss
  4. Press `a` — "Add Server" input modal should appear
  5. Paste a vless:// or vmess:// URI and press Enter — server should appear in list
  6. Press `j`/`k` — navigate server list, detail panel updates
  7. Press `/` — filter mode activates, type to search
  8. Press `s` — "Add Subscription" modal appears, paste a URL
  9. Press `p` — ping all servers, observe progress, list sorts by latency
  10. Press `d` on a server — server removed from list
  11. Resize terminal — layout should adapt smoothly
  12. Make terminal very small (under 60x20) — should show "too small" message
  13. Press `q` — TUI exits cleanly to shell
- Resume signal: Type "approved" or describe issues to fix
  </action>
  <verify>Human visual and interactive verification of all 13 test steps above</verify>
  <done>All 13 verification steps pass: TUI launches, navigation works, server management actions work, help overlay toggles, layout adapts, exit is clean</done>
</task>

</tasks>

<verification>
Full build and test pass:
```bash
cd /Users/lee/vless-terminal && go build ./... && go test ./...
```

Verify all server management commands exist:
```bash
cd /Users/lee/vless-terminal && grep -n 'func.*Cmd\b' internal/tui/ping.go internal/tui/input.go
```

Verify keybinding coverage matches requirements:
```bash
cd /Users/lee/vless-terminal && grep 'case "' internal/tui/app.go | head -20
```
</verification>

<success_criteria>
- Press `a` to add server via URI — parses and adds to store
- Press `s` to add subscription — fetches and stores servers
- Press `r` to refresh subscriptions — re-fetches all sources
- Press `d` to delete selected server
- Press `D` to clear all servers (with confirmation)
- Press `p` to ping all — runs concurrently, shows progress, sorts by latency
- Input modals render as overlays with enter/esc handling
- All existing tests pass (`go test ./...`)
- Human verification passes (Task 3 checkpoint)
</success_criteria>

<output>
After completion, create `.planning/phases/04-tui-and-server-interaction/04-03-SUMMARY.md`
</output>
