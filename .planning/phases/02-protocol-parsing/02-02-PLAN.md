---
phase: 02-protocol-parsing
plan: 02
type: tdd
wave: 2
depends_on: ["02-01"]
files_modified:
  - internal/serverstore/store.go
  - internal/serverstore/store_test.go
  - internal/subscription/fetch.go
  - internal/subscription/decode.go
  - internal/subscription/fetch_test.go
autonomous: true
requirements:
  - PROT-05
  - PROT-06

must_haves:
  truths:
    - "Server entries persist to a JSON file and survive app restarts (Load after Save returns identical data)"
    - "Server store supports Add, Remove, List, and Clear operations with correct behavior"
    - "Atomic writes prevent corruption -- writing to temp file then renaming"
    - "Fetching a subscription URL decodes the base64 response body and extracts all valid protocol URIs as Server entries"
    - "Subscription fetch handles base64 encoding variants (standard, URL-safe, padded, unpadded) and mixed line endings"
    - "Each server from a subscription has SubscriptionSource set to the subscription URL"
    - "Subscription with zero valid URIs after parsing returns an error"
    - "Concurrent access to the store is safe (RWMutex protects reads and writes)"
  artifacts:
    - path: "internal/serverstore/store.go"
      provides: "Server persistence with atomic writes and mutex protection"
      exports: ["New", "Store", "Load", "Save", "Add", "Remove", "List", "Clear", "FindByID"]
      contains: "sync.RWMutex"
    - path: "internal/serverstore/store_test.go"
      provides: "Round-trip persistence tests, CRUD operation tests"
      min_lines: 80
    - path: "internal/subscription/fetch.go"
      provides: "Subscription URL fetcher returning parsed servers"
      exports: ["Fetch"]
    - path: "internal/subscription/decode.go"
      provides: "Base64 decode utilities with BOM stripping and line normalization"
      exports: ["DecodeSubscription"]
    - path: "internal/subscription/fetch_test.go"
      provides: "Subscription tests with httptest mock server"
      min_lines: 60
  key_links:
    - from: "internal/subscription/fetch.go"
      to: "internal/protocol/parse.go"
      via: "Fetch calls protocol.ParseURI for each line in decoded subscription"
      pattern: "protocol\\.ParseURI\\("
    - from: "internal/serverstore/store.go"
      to: "internal/protocol/server.go"
      via: "Store holds []protocol.Server and serializes to JSON"
      pattern: "protocol\\.Server"
    - from: "internal/subscription/fetch.go"
      to: "internal/subscription/decode.go"
      via: "Fetch uses DecodeSubscription to decode base64 response body"
      pattern: "DecodeSubscription\\("
    - from: "internal/serverstore/store.go"
      to: "os.Rename"
      via: "Atomic write pattern: CreateTemp then Rename"
      pattern: "os\\.Rename\\("
---

<objective>
Implement the server JSON persistence store and subscription URL fetcher with TDD, completing the Phase 2 data pipeline from URI input to persistent storage.

Purpose: The server store provides crash-safe persistence for all server entries, while the subscription fetcher automates bulk server import from provider URLs. Together they complete the data flow: URI string -> parsed Server -> persistent store.

Output: `internal/serverstore/` package with CRUD operations and atomic writes, `internal/subscription/` package with HTTP fetching and base64 decoding, both with comprehensive tests.
</objective>

<execution_context>
@/Users/lee/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lee/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-protocol-parsing/02-RESEARCH.md
@.planning/phases/02-protocol-parsing/02-01-SUMMARY.md
@internal/config/paths.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create store and subscription stubs with failing tests</name>
  <files>
    internal/serverstore/store.go
    internal/serverstore/store_test.go
    internal/subscription/fetch.go
    internal/subscription/decode.go
    internal/subscription/fetch_test.go
  </files>
  <action>
RED phase: Create test suites and minimal stubs that compile but fail.

**1. Create `internal/serverstore/store.go`:**
- Define `Store` struct with fields: `mu sync.RWMutex`, `servers []protocol.Server`, `path string`.
- `func New(path string) *Store` -- constructor.
- Stub methods (all return error "not implemented"):
  - `func (s *Store) Load() error` -- reads JSON from s.path into s.servers
  - `func (s *Store) Save() error` -- writes s.servers to s.path atomically
  - `func (s *Store) Add(srv protocol.Server) error` -- appends server, saves
  - `func (s *Store) Remove(id string) error` -- removes by ID, saves
  - `func (s *Store) List() []protocol.Server` -- returns copy of servers
  - `func (s *Store) Clear() error` -- empties list, saves
  - `func (s *Store) FindByID(id string) (*protocol.Server, bool)` -- lookup by ID
  - `func (s *Store) Count() int` -- returns len(servers)
  - `func (s *Store) ReplaceBySource(source string, servers []protocol.Server) error` -- removes all servers with matching SubscriptionSource, adds new ones, saves (for subscription refresh per RESEARCH Open Question 3)

**2. Create `internal/serverstore/store_test.go`:**
Table-driven and scenario tests using `t.TempDir()` for isolated file paths:
- **TestSaveLoad_RoundTrip:** Save 2 servers, create new Store, Load, verify data matches (names, protocols, addresses, ports, all metadata fields).
- **TestAdd:** Add server, verify List() contains it, verify file exists on disk.
- **TestRemove:** Add 2 servers, remove one by ID, verify List() has only the remaining one.
- **TestClear:** Add 3 servers, Clear(), verify List() is empty, verify file on disk has empty array.
- **TestFindByID:** Add server, FindByID returns it. FindByID with unknown ID returns false.
- **TestLoadEmpty:** Load from non-existent file returns no error and empty list (not file-not-found error).
- **TestReplaceBySource:** Add 2 servers from source "sub1" and 1 from "manual", ReplaceBySource("sub1", newServers), verify manual server untouched and sub1 servers replaced.
- **TestConcurrentAccess:** Launch 10 goroutines doing Add concurrently, verify no race (run with `-race`).

**3. Create `internal/subscription/decode.go`:**
- `func DecodeSubscription(body []byte) (string, error)` -- stub returning "not implemented".
  This function: strips BOM, decodes base64 (trying all 4 variants), normalizes line endings to `\n`, returns decoded string.

**4. Create `internal/subscription/fetch.go`:**
- `func Fetch(subscriptionURL string) ([]*protocol.Server, error)` -- stub returning "not implemented".
  This function: HTTP GET with 30s timeout and User-Agent header, reads body, calls DecodeSubscription, splits by lines, calls protocol.ParseURI for each, sets SubscriptionSource on each server.

**5. Create `internal/subscription/fetch_test.go`:**
Tests using `net/http/httptest` for mock HTTP server:
- **TestFetch_ValidSubscription:** Mock server returns base64-encoded text with 3 VLESS URIs (one per line). Verify Fetch returns 3 servers with correct SubscriptionSource.
- **TestFetch_MixedProtocols:** Mock returns base64 text with 1 VLESS + 1 VMess + 1 Trojan + 1 SS URI. Verify all 4 parse correctly.
- **TestFetch_URLSafeBase64:** Mock returns URL-safe base64 without padding. Verify decoding works.
- **TestFetch_WindowsLineEndings:** Mock returns base64 content that decodes to `\r\n` line endings. Verify parsing still works.
- **TestFetch_BOMPrefix:** Mock returns content with UTF-8 BOM (0xEF 0xBB 0xBF) before base64. Verify BOM stripped.
- **TestFetch_InvalidLines:** Mock returns base64 text with 2 valid URIs and 1 garbage line. Verify 2 servers returned (garbage skipped).
- **TestFetch_AllInvalid:** Mock returns base64 text with only garbage lines. Verify error returned ("no valid server URIs").
- **TestFetch_HTTPError:** Mock returns 404. Verify error mentioning HTTP status.
- **TestFetch_EmptyBody:** Mock returns empty 200 response. Verify error.
- **TestDecodeSubscription_Variants:** Test DecodeSubscription directly with StdEncoding, RawStdEncoding, URLEncoding, RawURLEncoding inputs.

For VMess test URIs in subscription tests: construct valid vmess:// base64 JSON payloads in test helpers.

All tests MUST compile but FAIL (stubs return "not implemented").
  </action>
  <verify>
    <automated>cd /Users/lee/vless-terminal && go test ./internal/serverstore/ ./internal/subscription/ -count=1 -v 2>&1 | head -100</automated>
    <manual>Verify all tests compile and all test functions FAIL (RED phase).</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>All store and subscription test files compile. All tests run and FAIL with "not implemented" errors. Store struct and Fetch/DecodeSubscription stubs exist.</done>
</task>

<task type="auto">
  <name>Task 2: Implement store and subscription to pass all tests</name>
  <files>
    internal/serverstore/store.go
    internal/subscription/fetch.go
    internal/subscription/decode.go
  </files>
  <action>
GREEN phase: Implement all functionality to make every test pass.

**1. Implement `Store` methods in `store.go`:**

- **Load():** Lock with `s.mu.Lock()`. Read file at `s.path` with `os.ReadFile`. If `os.IsNotExist(err)`, set `s.servers = nil` and return nil (empty store is valid). Otherwise `json.Unmarshal` into `s.servers`.

- **Save():** Lock with `s.mu.RLock()`. Use atomic write pattern (RESEARCH Pattern 3):
  1. `json.MarshalIndent(s.servers, "", "  ")` for readable JSON
  2. `os.MkdirAll(filepath.Dir(s.path), 0700)` to ensure directory exists
  3. `os.CreateTemp(dir, "servers-*.json.tmp")` to create temp file
  4. Write data to temp file, close it
  5. `os.Rename(tmp.Name(), s.path)` for atomic replace
  6. `defer os.Remove(tmp.Name())` for cleanup on error

- **Add(srv):** Lock, append to `s.servers`, call `s.save()` (internal unlocked save). If srv.ID is empty, generate one with `protocol.NewID()`. If srv.AddedAt is zero, set to `time.Now()`.

- **Remove(id):** Lock, filter `s.servers` to exclude matching ID, call `s.save()`. Return error if ID not found.

- **List():** RLock, return a copy of the slice (not a reference to internal state).

- **Clear():** Lock, set `s.servers = nil`, call `s.save()`.

- **FindByID(id):** RLock, linear scan for matching ID. Return pointer and bool.

- **Count():** RLock, return `len(s.servers)`.

- **ReplaceBySource(source, newServers):** Lock, filter out all servers where `SubscriptionSource == source`, append newServers, call `s.save()`. Set AddedAt on new servers if zero.

Internal helper `save()` (no locking, called by methods that already hold lock) does the actual atomic write.

**2. Implement `DecodeSubscription` in `decode.go`:**
- Strip UTF-8 BOM (bytes `0xEF, 0xBB, 0xBF`) if present at start.
- Trim whitespace.
- Call `decodeBase64` (reuse the fallback chain pattern from `internal/protocol/helpers.go` -- but since this is a different package, implement a local copy or make the protocol helper exported). **Decision:** Create a local `decodeBase64` in this package to avoid coupling subscription to protocol internals. Same logic: try StdEncoding, RawStdEncoding, URLEncoding, RawURLEncoding.
- Normalize line endings: replace `\r\n` with `\n`, replace standalone `\r` with `\n`.
- Return decoded string.

**3. Implement `Fetch` in `fetch.go`:**
- Create `http.Client{Timeout: 30 * time.Second}`.
- Build `http.NewRequest("GET", subscriptionURL, nil)` with `User-Agent: Azad/1.0` header.
- Execute request, check `resp.StatusCode == 200` (return error with status code otherwise).
- Read body with `io.ReadAll`.
- Call `DecodeSubscription(body)` to decode.
- Split decoded string by `\n`, trim each line, skip empty lines.
- For each non-empty line, call `protocol.ParseURI(line)`. On error, skip (log-worthy but don't fail the whole fetch).
- Set `server.SubscriptionSource = subscriptionURL` on each successfully parsed server.
- If zero servers parsed, return error "subscription contained no valid server URIs".
- Return servers slice.

**CRITICAL:** Run tests with `-race` flag to verify concurrent access safety.
  </action>
  <verify>
    <automated>cd /Users/lee/vless-terminal && go test ./internal/serverstore/ ./internal/subscription/ -race -count=1 -v 2>&1 | tail -10</automated>
    <manual>Verify ALL tests pass with -race flag (GREEN phase). Zero failures, zero data races.</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>Server store persists to JSON with atomic writes and survives Load/Save round-trips. All CRUD operations work correctly. Subscription fetcher decodes base64 responses, handles encoding variants and BOM/line-ending issues, parses all protocol URIs, and sets SubscriptionSource. Concurrent access is race-free. All tests pass including -race.</done>
</task>

</tasks>

<verification>
1. `go test ./internal/serverstore/ ./internal/subscription/ -race -count=1 -v` -- all tests pass, no races
2. `go test ./internal/protocol/ -count=1` -- parsers still pass (no regression)
3. `go build ./cmd/azad` -- project still compiles
4. `go vet ./internal/serverstore/ ./internal/subscription/` -- no vet warnings
5. Verify servers.json file on disk after Save contains valid, human-readable JSON
6. Verify Load from non-existent file returns empty list (not error)
7. Verify subscription fetch with mixed protocols returns all valid servers
</verification>

<success_criteria>
- Server store Load/Save round-trip preserves all fields including timestamps
- Atomic write pattern: temp file + rename (no partial writes on crash)
- All CRUD operations (Add, Remove, List, Clear, FindByID, ReplaceBySource) work correctly
- Subscription fetch decodes base64 variants, handles BOM and mixed line endings
- Invalid URIs in subscriptions are skipped without failing the entire fetch
- Empty subscriptions return descriptive error
- Concurrent store access is race-free
- All tests pass with -race flag
</success_criteria>

<output>
After completion, create `.planning/phases/02-protocol-parsing/02-02-SUMMARY.md`
</output>
